/*!
 * froala_editor v3.2.6 (https://www.froala.com/wysiwyg-editor)
 * License https://froala.com/wysiwyg-editor/terms/
 * Copyright 2014-2021 Froala Labs
 */

{"version":3,"file":"code_beautifier.js","sources":["../../../src/js/plugins/code_beautifier.js"],"sourcesContent":["import FE from '../index.js'\r\n'use strict';\r\n\r\nFE.PLUGINS.codeBeautifier = function () {\r\n  /**\r\n     * HTML BEAUTIFIER\r\n     *\r\n     * LICENSE: The MIT License (MIT)\r\n     *\r\n     * Written by Nochum Sossonko, (nsossonko@hotmail.com)\r\n     *\r\n     * Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\r\n     * http://jsbeautifier.org/\r\n     *\r\n     */\r\n  /* jshint ignore:start */\r\n  /* jscs:disable */\r\n\r\n\r\n  const acorn = {};\r\n\r\n  (function (exports) {\r\n    /* jshint curly: false */\r\n    // This section of code is taken from acorn.\r\n    //\r\n    // Acorn was written by Marijn Haverbeke and released under an MIT\r\n    // license. The Unicode regexps (for identifiers and whitespace) were\r\n    // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\r\n    //\r\n    // Git repositories for Acorn are available at\r\n    //\r\n    //     http://marijnhaverbeke.nl/git/acorn\r\n    //     https://github.com/marijnh/acorn.git\r\n\r\n    // ## Character categories\r\n\r\n    // Big ugly regular expressions that match characters in the\r\n    // whitespace, identifier, and identifier-start categories. These\r\n    // are only applied when a character is found to actually have a\r\n    // code point above 128.\r\n\r\n    const nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/ // jshint ignore:line\r\n    const nonASCIIidentifierStartChars = '\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc'\r\n    const nonASCIIidentifierChars = '\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f'\r\n    const nonASCIIidentifierStart = new RegExp(`[${nonASCIIidentifierStartChars}]`)\r\n    const nonASCIIidentifier = new RegExp(`[${nonASCIIidentifierStartChars} ${nonASCIIidentifierChars}]`)\r\n\r\n    // Whether a single character denotes a newline.\r\n\r\n    exports.newline = /[\\n\\r\\u2028\\u2029]/\r\n\r\n    // Matches a whole line break (where CRLF is considered a single\r\n    // line break). Used to count lines.\r\n\r\n    // in javascript, these two differ\r\n    // in python they are the same, different methods are called on them\r\n    exports.lineBreak = new RegExp(`\\r\\n|${exports.newline.source}`)\r\n    exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g')\r\n\r\n\r\n    // Test whether a given character code starts an identifier.\r\n\r\n    exports.isIdentifierStart = function (code) {\r\n      // permit $ (36) and @ (64). @ is used in ES7 decorators.\r\n      if (code < 65) return code === 36 || code === 64\r\n      // 65 through 91 are uppercase letters.\r\n      if (code < 91) return true\r\n      // permit _ (95).\r\n      if (code < 97) return code === 95\r\n      // 97 through 123 are lowercase letters.\r\n      if (code < 123) return true\r\n      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\r\n    }\r\n\r\n    // Test whether a given character is part of an identifier.\r\n\r\n    exports.isIdentifierChar = function (code) {\r\n      if (code < 48) return code === 36\r\n      if (code < 58) return true\r\n      if (code < 65) return false\r\n      if (code < 91) return true\r\n      if (code < 97) return code === 95\r\n      if (code < 123) return true\r\n      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\r\n    }\r\n  })(acorn)\r\n\r\n  function run(html_source, options) {\r\n    function ltrim(s) {\r\n      return s.replace(/^\\s+/g, '')\r\n    }\r\n\r\n    function rtrim(s) {\r\n      return s.replace(/\\s+$/g, '')\r\n    }\r\n\r\n    let multi_parser\r\n    let indent_inner_html\r\n    let indent_size\r\n    let indent_character\r\n    let wrap_line_length\r\n    let brace_style\r\n    let unformatted\r\n    let preserve_newlines\r\n    let max_preserve_newlines\r\n    let indent_handlebars\r\n    let wrap_attributes\r\n    let wrap_attributes_indent_size\r\n    let end_with_newline\r\n    let extra_liners\r\n\r\n    options = options || {}\r\n\r\n    // backwards compatibility to 1.3.4\r\n    if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&\r\n            (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {\r\n      options.wrap_line_length = options.max_char\r\n    }\r\n\r\n    indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html\r\n    indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10)\r\n    indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char\r\n    brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style\r\n    wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10) \r\n    unformatted = options.unformatted || ['a', 'span', 'img', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',\r\n      'const', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike',\r\n      'font', 'ins', 'del', 'address', 'pre'\r\n    ]\r\n    preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines \r\n    max_preserve_newlines = preserve_newlines ?\r\n      (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10)) : 0 \r\n    indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars \r\n    wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes \r\n    wrap_attributes_indent_size = (options.wrap_attributes_indent_size === undefined) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10) || indent_size \r\n    end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline \r\n    extra_liners = Array.isArray(options.extra_liners) ?\r\n      options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?\r\n        options.extra_liners.split(',') : 'head,body,/html'.split(',') \r\n\r\n    if (options.indent_with_tabs) {\r\n      indent_character = '\\t' \r\n      indent_size = 1 \r\n    }\r\n\r\n    function Parser() {\r\n\r\n      this.pos = 0  //Parser position\r\n      this.token = '' \r\n      this.current_mode = 'CONTENT'  //reflects the current Parser mode: TAG/CONTENT\r\n      this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\r\n        parent: 'parent1',\r\n        parentcount: 1,\r\n        parent1: ''\r\n      } \r\n      this.tag_type = '' \r\n      this.token_text = this.last_token = this.last_text = this.token_type = '' \r\n      this.newlines = 0 \r\n      this.indent_content = indent_inner_html \r\n\r\n      this.Utils = { //Uilities made available to the various functions\r\n        whitespace: '\\n\\r\\t '.split(''),\r\n        single_token: 'br,input,link,meta,source,!doctype,basefont,base,area,hr,wbr,param,img,isindex,embed'.split(','), //all the single tags for HTML\r\n        extra_liners: extra_liners, //for tags that need a line of whitespace before them\r\n        in_array: function (what, arr) {\r\n          for (let i = 0;    i < arr.length;   i++) {\r\n            if (what === arr[i]) {\r\n              return true \r\n            }\r\n          }\r\n          return false \r\n        }\r\n      } \r\n\r\n      // Return true if the given text is composed entirely of whitespace.\r\n      this.is_whitespace = function (text) {\r\n        for (const n = 0;  n < text.length;  text++) {\r\n          if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {\r\n            return false \r\n          }\r\n        }\r\n        return true \r\n      } \r\n\r\n      this.traverse_whitespace = function () {\r\n        let input_char = '' \r\n\r\n        input_char = this.input.charAt(this.pos) \r\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n          this.newlines = 0 \r\n          while (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n            if (preserve_newlines && input_char === '\\n' && this.newlines <= max_preserve_newlines) {\r\n              this.newlines += 1 \r\n            }\r\n\r\n            this.pos++ \r\n            input_char = this.input.charAt(this.pos) \r\n          }\r\n          return true \r\n        }\r\n        return false \r\n      } \r\n\r\n      // Append a space to the given content (string array) or, if we are\r\n      // at the wrap_line_length, append a newline/indentation.\r\n      this.space_or_wrap = function (content) {\r\n        if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached\r\n          this.print_newline(false, content) \r\n          this.print_indentation(content) \r\n        } else {\r\n          this.line_char_count++ \r\n          content.push(' ') \r\n        }\r\n      } \r\n\r\n      this.get_content = function () { //function to capture regular content between tags\r\n        let input_char = '',\r\n          content = [] \r\n\r\n        while (this.input.charAt(this.pos) != '<') {\r\n          if (this.pos >= this.input.length) {\r\n            return content.length ? content.join('') : ['', 'TK_EOF'] \r\n          }\r\n\r\n          if (this.traverse_whitespace()) {\r\n            this.space_or_wrap(content) \r\n            continue \r\n          }\r\n\r\n          if (indent_handlebars) {\r\n            // Handlebars parsing is complicated.\r\n            // {{#foo}} and {{/foo}} are formatted tags.\r\n            // {{something}} should get treated as content, except:\r\n            // {{else}} specifically behaves like {{#if}} and {{/if}}\r\n            const peek3 = this.input.substr(this.pos, 3) \r\n            if (peek3 === '{{#' || peek3 === '{{/') {\r\n              // These are tags and not content.\r\n              break \r\n            } else if (peek3 === '{{!') {\r\n              return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'] \r\n            } else if (this.input.substr(this.pos, 2) === '{{') {\r\n              if (this.get_tag(true) === '{{else}}') {\r\n                break \r\n              }\r\n            }\r\n          }\r\n\r\n          input_char = this.input.charAt(this.pos) \r\n          this.pos++ \r\n          this.line_char_count++ \r\n          content.push(input_char)  //letter at-a-time (or string) inserted to an array\r\n        }\r\n        return content.length ? content.join('') : '' \r\n      } \r\n\r\n      this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify\r\n        if (this.pos === this.input.length) {\r\n          return ['', 'TK_EOF'] \r\n        }\r\n        let content = '' \r\n        const reg_match = new RegExp(`</${name}\\\\s*>`, 'igm') \r\n        reg_match.lastIndex = this.pos \r\n        const reg_array = reg_match.exec(this.input) \r\n        const end_script = reg_array ? reg_array.index : this.input.length  //absolute end of script\r\n        if (this.pos < end_script) { //get everything in between the script tags\r\n          content = this.input.substring(this.pos, end_script) \r\n          this.pos = end_script \r\n        }\r\n        return content \r\n      } \r\n\r\n      this.record_tag = function (tag) { //function to record a tag and its parent in this.tags Object\r\n        if (this.tags[`${tag}count`]) { //check for the existence of this tag type\r\n          this.tags[`${tag}count`]++ \r\n          this.tags[tag + this.tags[`${tag}count`]] = this.indent_level  //and record the present indent level\r\n        } else { //otherwise initialize this tag type\r\n          this.tags[`${tag}count`] = 1 \r\n          this.tags[tag + this.tags[`${tag}count`]] = this.indent_level  //and record the present indent level\r\n        }\r\n        this.tags[tag + this.tags[`${tag}count`] + 'parent'] = this.tags.parent  //set the parent (i.e. in the case of a div this.tags.div1parent)\r\n        this.tags.parent = tag + this.tags[`${tag}count`]  //and make this the current parent (i.e. in the case of a div 'div1')\r\n      } \r\n\r\n      this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer\r\n        if (this.tags[`${tag}count`]) { //if the openener is not in the Object we ignore it\r\n          let temp_parent = this.tags.parent  //check to see if it's a closable tag.\r\n          while (temp_parent) { //till we reach '' (the initial value) \r\n            if (tag + this.tags[`${tag}count`] === temp_parent) { //if this is it use it\r\n              break \r\n            }\r\n            temp_parent = this.tags[`${temp_parent}parent`]  //otherwise keep on climbing up the DOM Tree\r\n          }\r\n          if (temp_parent) { //if we caught something\r\n            this.indent_level = this.tags[tag + this.tags[`${tag}count`]]  //set the indent_level accordingly\r\n            this.tags.parent = this.tags[temp_parent + 'parent']  //and set the current parent\r\n          }\r\n          delete this.tags[tag + this.tags[`${tag}count`] + 'parent']  //delete the closed tags parent reference...\r\n          delete this.tags[tag + this.tags[`${tag}count`]]  //...and the tag itself\r\n          if (this.tags[`${tag}count`] === 1) {\r\n            delete this.tags[`${tag}count`] \r\n          } else {\r\n            this.tags[`${tag}count`]-- \r\n          }\r\n        }\r\n      } \r\n\r\n      this.indent_to_tag = function (tag) {\r\n        // Match the indentation level to the last use of this tag, but don't remove it.\r\n        if (!this.tags[`${tag}count`]) {\r\n          return \r\n        }\r\n        let temp_parent = this.tags.parent \r\n        while (temp_parent) {\r\n          if (tag + this.tags[`${tag}count`] === temp_parent) {\r\n            break \r\n          }\r\n          temp_parent = this.tags[`${temp_parent}parent`] \r\n        }\r\n        if (temp_parent) {\r\n          this.indent_level = this.tags[tag + this.tags[`${tag}count`]] \r\n        }\r\n      } \r\n\r\n      this.get_tag = function (peek) { //function to get a full tag and parse its type\r\n        let input_char = '',\r\n          content = [],\r\n          comment = '',\r\n          space = false,\r\n          first_attr = true,\r\n          tag_start, \r\n          tag_end,\r\n          tag_start_char,\r\n          orig_pos = this.pos,\r\n          orig_line_char_count = this.line_char_count \r\n\r\n        peek = peek !== undefined ? peek : false \r\n\r\n        do {\r\n          if (this.pos >= this.input.length) {\r\n            if (peek) {\r\n              this.pos = orig_pos \r\n              this.line_char_count = orig_line_char_count \r\n            }\r\n            return content.length ? content.join('') : ['', 'TK_EOF'] \r\n          }\r\n\r\n          input_char = this.input.charAt(this.pos) \r\n          this.pos++ \r\n\r\n          if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\r\n            space = true \r\n            continue \r\n          }\r\n\r\n          if (input_char === '\\'' || input_char === '\"') {\r\n            input_char += this.get_unformatted(input_char) \r\n            space = true \r\n\r\n          }\r\n\r\n          if (input_char === '=') { //no space before =\r\n            space = false \r\n          }\r\n\r\n          if (content.length && content[content.length - 1] != '=' && input_char != '>' && space) {\r\n            //no space after = or before >\r\n            this.space_or_wrap(content) \r\n            space = false \r\n            if (!first_attr && wrap_attributes === 'force' && input_char != '/') {\r\n              this.print_newline(true, content) \r\n              this.print_indentation(content) \r\n              for (let count = 0;  count < wrap_attributes_indent_size;  count++) {\r\n                content.push(indent_character) \r\n              }\r\n            }\r\n            for (let i = 0;  i < content.length;  i++) {\r\n              if (content[i] === ' ') {\r\n                first_attr = false \r\n                break \r\n              }\r\n            }\r\n          }\r\n\r\n          if (indent_handlebars && tag_start_char === '<') {\r\n            // When inside an angle-bracket tag, put spaces around\r\n            // handlebars not inside of strings.\r\n            if ((input_char + this.input.charAt(this.pos)) === '{{') {\r\n              input_char += this.get_unformatted('}}') \r\n              if (content.length && content[content.length - 1] != ' ' && content[content.length - 1] != '<') {\r\n                input_char = ` ${input_char}` \r\n              }\r\n              space = true \r\n            }\r\n          }\r\n\r\n          if (input_char === '<' && !tag_start_char) {\r\n            tag_start = this.pos - 1 \r\n            tag_start_char = '<' \r\n          }\r\n\r\n          if (indent_handlebars && !tag_start_char) {\r\n            if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {\r\n              if (input_char === '#' || input_char === '/' || input_char === '!') {\r\n                tag_start = this.pos - 3 \r\n              } else {\r\n                tag_start = this.pos - 2 \r\n              }\r\n              tag_start_char = '{' \r\n            }\r\n          }\r\n\r\n          this.line_char_count++ \r\n          content.push(input_char)  //inserts character at-a-time (or string)\r\n\r\n          if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special\r\n            // We treat all comments as literals, even more than preformatted tags\r\n            // we just look for the appropriate close tag\r\n            content = [this.get_comment(tag_start)] \r\n            break \r\n          }\r\n\r\n          if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special\r\n            // We treat all comments as literals, even more than preformatted tags\r\n            // we just look for the appropriate close tag\r\n            content = [this.get_comment(tag_start)] \r\n            break \r\n          }\r\n\r\n          if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {\r\n            break \r\n          }\r\n        } while (input_char != '>') \r\n\r\n        const tag_complete = content.join('') \r\n        let tag_index \r\n        let tag_offset \r\n\r\n        if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends\r\n          tag_index = tag_complete.indexOf(' ') \r\n        } else if (tag_complete[0] === '{') {\r\n          tag_index = tag_complete.indexOf('}') \r\n        } else { //otherwise go with the tag ending\r\n          tag_index = tag_complete.indexOf('>') \r\n        }\r\n        if (tag_complete[0] === '<' || !indent_handlebars) {\r\n          tag_offset = 1 \r\n        } else {\r\n          tag_offset = tag_complete[2] === '#' ? 3 : 2 \r\n        }\r\n        const tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase() \r\n        if (tag_complete.charAt(tag_complete.length - 2) === '/' ||\r\n                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\r\n          if (!peek) {\r\n            this.tag_type = 'SINGLE' \r\n          }\r\n        } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {\r\n          if (!peek) {\r\n            this.indent_to_tag('if') \r\n            this.tag_type = 'HANDLEBARS_ELSE' \r\n            this.indent_content = true \r\n            this.traverse_whitespace() \r\n          }\r\n        } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\r\n          comment = this.get_unformatted(`</${tag_check}>`, tag_complete)  //...delegate to get_unformatted function\r\n          content.push(comment) \r\n          tag_end = this.pos - 1 \r\n          this.tag_type = 'SINGLE' \r\n        } else if (tag_check === 'script' &&\r\n                    (tag_complete.search('type') === -1 ||\r\n                        (tag_complete.search('type') > -1 &&\r\n                            tag_complete.search(/\\b(text|application)\\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {\r\n          if (!peek) {\r\n            this.record_tag(tag_check) \r\n            this.tag_type = 'SCRIPT' \r\n          }\r\n        } else if (tag_check === 'style' &&\r\n                    (tag_complete.search('type') === -1 ||\r\n                        (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {\r\n          if (!peek) {\r\n            this.record_tag(tag_check) \r\n            this.tag_type = 'STYLE' \r\n          }\r\n        } else if (tag_check.charAt(0) === '!') { //peek for <! comment\r\n          // for comments content is already correct.\r\n          if (!peek) {\r\n            this.tag_type = 'SINGLE' \r\n            this.traverse_whitespace() \r\n          }\r\n        } else if (!peek) {\r\n          if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\r\n            this.retrieve_tag(tag_check.substring(1))  //remove it and all ancestors\r\n            this.tag_type = 'END' \r\n          } else { //otherwise it's a start-tag\r\n            this.record_tag(tag_check)  //push it on the tag stack\r\n            if (tag_check.toLowerCase() != 'html') {\r\n              this.indent_content = true \r\n            }\r\n            this.tag_type = 'START' \r\n          }\r\n\r\n          // Allow preserving of newlines after a start or end tag\r\n          if (this.traverse_whitespace()) {\r\n            this.space_or_wrap(content) \r\n          }\r\n\r\n          if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\r\n            this.print_newline(false, this.output) \r\n            if (this.output.length && this.output[this.output.length - 2] != '\\n') {\r\n              this.print_newline(true, this.output) \r\n            }\r\n          }\r\n        }\r\n\r\n        if (peek) {\r\n          this.pos = orig_pos \r\n          this.line_char_count = orig_line_char_count \r\n        }\r\n\r\n        return content.join('')  //returns fully formatted tag\r\n      } \r\n\r\n      this.get_comment = function (start_pos) { //function to return comment content in its entirety\r\n        // this is will have very poor perf, but will work for now.\r\n        let comment = '',\r\n          delimiter = '>',\r\n          matched = false \r\n\r\n        this.pos = start_pos \r\n        let input_char = this.input.charAt(this.pos) \r\n        this.pos++ \r\n\r\n        while (this.pos <= this.input.length) {\r\n          comment += input_char \r\n\r\n          // only need to check for the delimiter if the last chars match\r\n          if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&\r\n                        comment.indexOf(delimiter) != -1) {\r\n            break \r\n          }\r\n\r\n          // only need to search for custom delimiter for the first few characters\r\n          if (!matched && comment.length < 10) {\r\n            if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment\r\n              delimiter = '<![endif]>' \r\n              matched = true \r\n            } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...\r\n              delimiter = ']]>' \r\n              matched = true \r\n            } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...\r\n              delimiter = ']>' \r\n              matched = true \r\n            } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...\r\n              delimiter = '-->' \r\n              matched = true \r\n            } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment\r\n              delimiter = '}}' \r\n              matched = true \r\n            } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment\r\n              delimiter = '?>' \r\n              matched = true \r\n            } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment\r\n              delimiter = '%>' \r\n              matched = true \r\n            }\r\n          }\r\n\r\n          input_char = this.input.charAt(this.pos) \r\n          this.pos++ \r\n        }\r\n\r\n        return comment \r\n      } \r\n\r\n      this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety\r\n\r\n        if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) != -1) {\r\n          return '' \r\n        }\r\n        let input_char = '' \r\n        let content = '' \r\n        let min_index = 0 \r\n        let space = true \r\n        do {\r\n\r\n          if (this.pos >= this.input.length) {\r\n            return content \r\n          }\r\n\r\n          input_char = this.input.charAt(this.pos) \r\n          this.pos++ \r\n\r\n          if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n            if (!space) {\r\n              this.line_char_count-- \r\n              continue \r\n            }\r\n            if (input_char === '\\n' || input_char === '\\r') {\r\n              content += '\\n' \r\n              /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\r\n                          for (const i=0  i<this.indent_level  i++) {\r\n                            content += this.indent_string \r\n                          }\r\n                          space = false  //...and make sure other indentation is erased\r\n                          */\r\n              this.line_char_count = 0 \r\n              continue \r\n            }\r\n          }\r\n          content += input_char \r\n          this.line_char_count++ \r\n          space = true \r\n\r\n          if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {\r\n            // Handlebars expressions in strings should also be unformatted.\r\n            content += this.get_unformatted('}}') \r\n            // These expressions are opaque.  Ignore delimiters found in them.\r\n            min_index = content.length \r\n          }\r\n        } while (content.toLowerCase().indexOf(delimiter, min_index) === -1) \r\n        return content \r\n      } \r\n\r\n      this.get_token = function () { //initial handler for token-retrieval\r\n        let token \r\n\r\n        if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\r\n          const type = this.last_token.substr(7) \r\n          token = this.get_contents_to(type) \r\n          if (typeof token != 'string') {\r\n            return token \r\n          }\r\n          return [token, `TK_${type}`] \r\n        }\r\n        if (this.current_mode === 'CONTENT') {\r\n          token = this.get_content() \r\n          if (typeof token != 'string') {\r\n            return token \r\n          } else {\r\n            return [token, 'TK_CONTENT'] \r\n          }\r\n        }\r\n\r\n        if (this.current_mode === 'TAG') {\r\n          token = this.get_tag() \r\n          if (typeof token != 'string') {\r\n            return token \r\n          } else {\r\n            const tag_name_type = `TK_TAG_${this.tag_type}` \r\n            return [token, tag_name_type] \r\n          }\r\n        }\r\n      } \r\n\r\n      this.get_full_indent = function (level) {\r\n        level = this.indent_level + level || 0 \r\n        if (level < 1) {\r\n          return '' \r\n        }\r\n\r\n        return (new Array(level + 1)).join(this.indent_string) \r\n      } \r\n\r\n      this.is_unformatted = function (tag_check, unformatted) {\r\n        //is this an HTML5 block-level link?\r\n        if (!this.Utils.in_array(tag_check, unformatted)) {\r\n          return false \r\n        }\r\n\r\n        if (tag_check.toLowerCase() != 'a' || !this.Utils.in_array('a', unformatted)) {\r\n          return true \r\n        }\r\n\r\n        //at this point we have an  tag  is its first child something we want to remain\r\n        //unformatted?\r\n        const next_tag = this.get_tag(true /* peek. */) \r\n\r\n        // test next_tag to see if it is just html tag (no external content)\r\n        const tag = (next_tag || '').match(/^\\s*<\\s*\\/?([a-z]*)\\s*[^>]*>\\s*$/) \r\n\r\n        // if next_tag comes back but is not an isolated tag, then\r\n        // let's treat the 'a' tag as having content\r\n        // and respect the unformatted option\r\n        if (!tag || this.Utils.in_array(tag, unformatted)) {\r\n          return true \r\n        } else {\r\n          return false \r\n        }\r\n      } \r\n\r\n      this.printer = function (js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions\r\n\r\n        this.input = js_source || ''  //gets the input for the Parser\r\n        this.output = [] \r\n        this.indent_character = indent_character \r\n        this.indent_string = '' \r\n        this.indent_size = indent_size \r\n        this.brace_style = brace_style \r\n        this.indent_level = 0 \r\n        this.wrap_line_length = wrap_line_length \r\n        this.line_char_count = 0  //count to see if wrap_line_length was exceeded\r\n\r\n        for (let i = 0;  i < this.indent_size;  i++) {\r\n          this.indent_string += this.indent_character \r\n        }\r\n\r\n        this.print_newline = function (force, arr) {\r\n          this.line_char_count = 0 \r\n          if (!arr || !arr.length) {\r\n            return \r\n          }\r\n          if (force || (arr[arr.length - 1] != '\\n')) { //we might want the extra line\r\n            if ((arr[arr.length - 1] != '\\n')) {\r\n              arr[arr.length - 1] = rtrim(arr[arr.length - 1]) \r\n            }\r\n            arr.push('\\n') \r\n          }\r\n        } \r\n\r\n        this.print_indentation = function (arr) {\r\n          for (let i = 0;  i < this.indent_level;  i++) {\r\n            arr.push(this.indent_string) \r\n            this.line_char_count += this.indent_string.length \r\n          }\r\n        } \r\n\r\n        this.print_token = function (text) {\r\n          // Avoid printing initial whitespace.\r\n          if (this.is_whitespace(text) && !this.output.length) {\r\n            return \r\n          }\r\n          if (text || text !== '') {\r\n            if (this.output.length && this.output[this.output.length - 1] === '\\n') {\r\n              this.print_indentation(this.output) \r\n              text = ltrim(text) \r\n            }\r\n          }\r\n          this.print_token_raw(text) \r\n        } \r\n\r\n        this.print_token_raw = function (text) {\r\n          // If we are going to print newlines, truncate trailing\r\n          // whitespace, as the newlines will represent the space.\r\n          if (this.newlines > 0) {\r\n            text = rtrim(text) \r\n          }\r\n\r\n          if (text && text !== '') {\r\n            if (text.length > 1 && text[text.length - 1] === '\\n') {\r\n              // unformatted tags can grab newlines as their last character\r\n              this.output.push(text.slice(0, -1)) \r\n              this.print_newline(false, this.output) \r\n            } else {\r\n              this.output.push(text) \r\n            }\r\n          }\r\n\r\n          for (let n = 0;  n < this.newlines;  n++) {\r\n            this.print_newline(n > 0, this.output) \r\n          }\r\n          this.newlines = 0 \r\n        } \r\n\r\n        this.indent = function () {\r\n          this.indent_level++ \r\n        } \r\n\r\n        this.unindent = function () {\r\n          if (this.indent_level > 0) {\r\n            this.indent_level-- \r\n          }\r\n        } \r\n      } \r\n      return this \r\n    }\r\n\r\n    /*_____________________--------------------_____________________*/\r\n\r\n    multi_parser = new Parser()  //wrapping functions Parser\r\n    multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style)  //initialize starting values\r\n\r\n    while (true) {\r\n      const t = multi_parser.get_token() \r\n      multi_parser.token_text = t[0] \r\n      multi_parser.token_type = t[1] \r\n\r\n      if (multi_parser.token_type === 'TK_EOF') {\r\n        break \r\n      }\r\n\r\n      switch (multi_parser.token_type) {\r\n      case 'TK_TAG_START':\r\n        multi_parser.print_newline(false, multi_parser.output) \r\n        multi_parser.print_token(multi_parser.token_text) \r\n        if (multi_parser.indent_content) {\r\n          multi_parser.indent() \r\n          multi_parser.indent_content = false \r\n        }\r\n        multi_parser.current_mode = 'CONTENT' \r\n        break \r\n      case 'TK_TAG_STYLE':\r\n      case 'TK_TAG_SCRIPT':\r\n        multi_parser.print_newline(false, multi_parser.output) \r\n        multi_parser.print_token(multi_parser.token_text) \r\n        multi_parser.current_mode = 'CONTENT' \r\n        break \r\n      case 'TK_TAG_END':\r\n        // Print new line only if the tag has no content and has child\r\n        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\r\n          const tag_name = multi_parser.token_text.match(/\\w+/)[0] \r\n          let tag_extracted_from_last_output = null \r\n          if (multi_parser.output.length) {\r\n            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\\/?\\s*(\\w+)/)\r\n          }\r\n          if (tag_extracted_from_last_output === null ||\r\n                            (tag_extracted_from_last_output[1] != tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {\r\n            multi_parser.print_newline(false, multi_parser.output) \r\n          }\r\n        }\r\n        multi_parser.print_token(multi_parser.token_text) \r\n        multi_parser.current_mode = 'CONTENT' \r\n        break \r\n      case 'TK_TAG_SINGLE':\r\n        // Don't add a newline before elements that should remain unformatted.\r\n        const tag_check = multi_parser.token_text.match(/^\\s*<([a-z-]+)/i) \r\n        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {\r\n          multi_parser.print_newline(false, multi_parser.output) \r\n        }\r\n        multi_parser.print_token(multi_parser.token_text) \r\n        multi_parser.current_mode = 'CONTENT' \r\n        break \r\n      case 'TK_TAG_HANDLEBARS_ELSE':\r\n        multi_parser.print_token(multi_parser.token_text) \r\n        if (multi_parser.indent_content) {\r\n          multi_parser.indent() \r\n          multi_parser.indent_content = false \r\n        }\r\n        multi_parser.current_mode = 'CONTENT' \r\n        break \r\n      case 'TK_TAG_HANDLEBARS_COMMENT':\r\n        multi_parser.print_token(multi_parser.token_text) \r\n        multi_parser.current_mode = 'TAG' \r\n        break \r\n      case 'TK_CONTENT':\r\n        multi_parser.print_token(multi_parser.token_text) \r\n        multi_parser.current_mode = 'TAG' \r\n        break \r\n      case 'TK_STYLE':\r\n      case 'TK_SCRIPT':\r\n        if (multi_parser.token_text !== '') {\r\n          multi_parser.print_newline(false, multi_parser.output) \r\n          let { token_text : text } = multi_parser \r\n          let _beautifier \r\n          let script_indent_level = 1 \r\n\r\n          if (multi_parser.token_type === 'TK_SCRIPT') {\r\n            _beautifier = typeof js_beautify === 'function' && js_beautify \r\n          } else if (multi_parser.token_type === 'TK_STYLE') {\r\n            _beautifier = typeof css_beautify === 'function' && css_beautify \r\n          }\r\n\r\n          if (options.indent_scripts === 'keep') {\r\n            script_indent_level = 0 \r\n          } else if (options.indent_scripts === 'separate') {\r\n            script_indent_level = -multi_parser.indent_level \r\n          }\r\n\r\n          const indentation = multi_parser.get_full_indent(script_indent_level) \r\n          if (_beautifier) {\r\n            // call the Beautifier if avaliable\r\n            text = _beautifier(text.replace(/^\\s*/, indentation), options) \r\n          } else {\r\n            // simply indent the string otherwise\r\n            const white = text.match(/^\\s*/)[0] \r\n            const _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1 \r\n            const reindent = multi_parser.get_full_indent(script_indent_level - _level) \r\n\r\n            text = text.replace(/^\\s*/, indentation)\r\n              .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\r\n              .replace(/\\s+$/, '') \r\n          }\r\n          if (text) {\r\n            multi_parser.print_token_raw(text) \r\n            multi_parser.print_newline(true, multi_parser.output) \r\n          }\r\n        }\r\n        multi_parser.current_mode = 'TAG' \r\n        break \r\n      default:\r\n        // We should not be getting here but we don't want to drop input on the floor\r\n        // Just output the text and move on\r\n        if (multi_parser.token_text !== '') {\r\n          multi_parser.print_token(multi_parser.token_text) \r\n        }\r\n        break \r\n      }\r\n      multi_parser.last_token = multi_parser.token_type \r\n      multi_parser.last_text = multi_parser.token_text \r\n    }\r\n    let sweet_code = multi_parser.output.join('').replace(/[\\r\\n\\t ]+$/, '') \r\n    if (end_with_newline) {\r\n      sweet_code += '\\n' \r\n    }\r\n    return sweet_code \r\n  }\r\n\r\n  function css_beautify(source_text, options) {\r\n    const NESTED_AT_RULE = {\r\n      '@page': true,\r\n      '@font-face': true,\r\n      '@keyframes': true,\r\n      // also in CONDITIONAL_GROUP_RULE below\r\n      '@media': true,\r\n      '@supports': true,\r\n      '@document': true\r\n    } \r\n    const CONDITIONAL_GROUP_RULE = {\r\n      '@media': true,\r\n      '@supports': true,\r\n      '@document': true\r\n    } \r\n\r\n    options = options || {} \r\n    source_text = source_text || '' \r\n    // HACK: newline parsing inconsistent. This brute force normalizes the input.\r\n    source_text = source_text.replace(/\\r\\n|[\\r\\u2028\\u2029]/g, '\\n')\r\n\r\n    let indentSize = options.indent_size || 4 \r\n    let indentCharacter = options.indent_char || ' ' \r\n    const selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline \r\n    const end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline \r\n    const newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules \r\n    let eol = options.eol ? options.eol : '\\n' \r\n\r\n    // compatibility\r\n    if (typeof indentSize === 'string') {\r\n      indentSize = parseInt(indentSize, 10) \r\n    }\r\n\r\n    if (options.indent_with_tabs) {\r\n      indentCharacter = '\\t' \r\n      indentSize = 1 \r\n    }\r\n\r\n    eol = eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n')\r\n\r\n\r\n    // tokenizer\r\n    const whiteRe = /^\\s+$/ \r\n    const wordRe = /[\\w$\\-_]/ \r\n\r\n    let pos = -1,\r\n      ch \r\n    let parenLevel = 0 \r\n\r\n    function next() {\r\n      ch = source_text.charAt(++pos) \r\n      return ch || '' \r\n    }\r\n\r\n    function peek(skipWhitespace) {\r\n      let result = '' \r\n      const prev_pos = pos \r\n      if (skipWhitespace) {\r\n        eatWhitespace() \r\n      }\r\n      result = source_text.charAt(pos + 1) || '' \r\n      pos = prev_pos - 1 \r\n      next() \r\n      return result \r\n    }\r\n\r\n    function eatString(endChars) {\r\n      const start = pos \r\n      while (next()) {\r\n        if (ch === '\\\\') {\r\n          next() \r\n        } else if (endChars.indexOf(ch) !== -1) {\r\n          break \r\n        } else if (ch === '\\n') {\r\n          break \r\n        }\r\n      }\r\n      return source_text.substring(start, pos + 1) \r\n    }\r\n\r\n    function peekString(endChar) {\r\n      const prev_pos = pos \r\n      const str = eatString(endChar) \r\n      pos = prev_pos - 1 \r\n      next() \r\n      return str \r\n    }\r\n\r\n    function eatWhitespace() {\r\n      let result = '' \r\n      while (whiteRe.test(peek())) {\r\n        next() \r\n        result += ch \r\n      }\r\n      return result \r\n    }\r\n\r\n    function skipWhitespace() {\r\n      let result = '' \r\n      if (ch && whiteRe.test(ch)) {\r\n        result = ch \r\n      }\r\n      while (whiteRe.test(next())) {\r\n        result += ch \r\n      }\r\n      return result \r\n    }\r\n\r\n    function eatComment(singleLine) {\r\n      const start = pos \r\n      singleLine = peek() === '/' \r\n      next() \r\n      while (next()) {\r\n        if (!singleLine && ch === '*' && peek() === '/') {\r\n          next() \r\n          break \r\n        } else if (singleLine && ch === '\\n') {\r\n          return source_text.substring(start, pos) \r\n        }\r\n      }\r\n\r\n      return source_text.substring(start, pos) + ch \r\n    }\r\n\r\n\r\n    function lookBack(str) {\r\n      return source_text.substring(pos - str.length, pos).toLowerCase() ===\r\n                str \r\n    }\r\n\r\n    // Nested pseudo-class if we are insideRule\r\n    // and the next special character found opens\r\n    // a new block\r\n    function foundNestedPseudoClass() {\r\n      let openParen = 0 \r\n      for (let i = pos + 1;  i < source_text.length;  i++) {\r\n        const ch = source_text.charAt(i) \r\n        if (ch === '{') {\r\n          return true \r\n        } else if (ch === '(') {\r\n          // pseudoclasses can contain ()\r\n          openParen += 1 \r\n        } else if (ch === ')') {\r\n          if (openParen === 0) {\r\n            return false \r\n          }\r\n          openParen -= 1 \r\n        } else if (ch === ' ' || ch === '}') {\r\n          return false \r\n        }\r\n      }\r\n      return false \r\n    }\r\n\r\n    // printer\r\n    let basebaseIndentString = source_text.match(/^[\\t ]*/)[0] \r\n    const singleIndent = new Array(indentSize + 1).join(indentCharacter) \r\n    let indentLevel = 0 \r\n    let nestedLevel = 0 \r\n\r\n    function indent() {\r\n      indentLevel++ \r\n      basebaseIndentString += singleIndent \r\n    }\r\n\r\n    function outdent() {\r\n      indentLevel-- \r\n      basebaseIndentString = basebaseIndentString.slice(0, -indentSize) \r\n    }\r\n\r\n    const print = {} \r\n    print['{'] = function (ch) {\r\n      print.singleSpace() \r\n      output.push(ch) \r\n      print.newLine() \r\n    } \r\n    print['}'] = function (ch) {\r\n      print.newLine() \r\n      output.push(ch) \r\n      print.newLine() \r\n    } \r\n\r\n    print._lastCharWhitespace = function () {\r\n      return whiteRe.test(output[output.length - 1]) \r\n    } \r\n\r\n    print.newLine = function (keepWhitespace) {\r\n      if (output.length) {\r\n        if (!keepWhitespace && output[output.length - 1] !== '\\n') {\r\n          print.trim() \r\n        }\r\n\r\n        output.push('\\n') \r\n\r\n        if (basebaseIndentString) {\r\n          output.push(basebaseIndentString) \r\n        }\r\n      }\r\n    } \r\n    print.singleSpace = function () {\r\n      if (output.length && !print._lastCharWhitespace()) {\r\n        output.push(' ') \r\n      }\r\n    } \r\n\r\n    print.preserveSingleSpace = function () {\r\n      if (isAfterSpace) {\r\n        print.singleSpace() \r\n      }\r\n    } \r\n\r\n    print.trim = function () {\r\n      while (print._lastCharWhitespace()) {\r\n        output.pop() \r\n      }\r\n    } \r\n\r\n\r\n    const output = [] \r\n    /*_____________________--------------------_____________________*/\r\n\r\n    let insideRule = false \r\n    let insidePropertyValue = false \r\n    let enteringConditionalGroup = false \r\n    let top_ch = '' \r\n    let last_top_ch = '' \r\n    let isAfterSpace\r\n\r\n    while (true) {\r\n      const whitespace = skipWhitespace() \r\n      isAfterSpace = whitespace !== '' \r\n      const isAfterNewline = whitespace.indexOf('\\n') !== -1 \r\n      last_top_ch = top_ch \r\n      top_ch = ch \r\n\r\n      if (!ch) {\r\n        break \r\n      } else if (ch === '/' && peek() === '*') { /* css comment */\r\n        const header = indentLevel === 0 \r\n\r\n        if (isAfterNewline || header) {\r\n          print.newLine() \r\n        }\r\n\r\n        output.push(eatComment()) \r\n        print.newLine() \r\n        if (header) {\r\n          print.newLine(true) \r\n        }\r\n      } else if (ch === '/' && peek() === '/') { // single line comment\r\n        if (!isAfterNewline && last_top_ch !== '{') {\r\n          print.trim() \r\n        }\r\n        print.singleSpace() \r\n        output.push(eatComment()) \r\n        print.newLine() \r\n      } else if (ch === '@') {\r\n        print.preserveSingleSpace() \r\n        output.push(ch) \r\n\r\n        // strip trailing space, if present, for hash property checks\r\n        let variableOrRule = peekString(': , {}()[]/=\\'\"') \r\n\r\n        if (variableOrRule.match(/[ :]$/)) {\r\n          // we have a variable or pseudo-class, add it and insert one space before continuing\r\n          next() \r\n          variableOrRule = eatString(': ').replace(/\\s$/, '') \r\n          output.push(variableOrRule) \r\n          print.singleSpace() \r\n        }\r\n\r\n        variableOrRule = variableOrRule.replace(/\\s$/, '')\r\n\r\n        // might be a nesting at-rule\r\n        if (variableOrRule in NESTED_AT_RULE) {\r\n          nestedLevel += 1 \r\n          if (variableOrRule in CONDITIONAL_GROUP_RULE) {\r\n            enteringConditionalGroup = true \r\n          }\r\n        }\r\n      } else if (ch === '#' && peek() === '{') {\r\n        print.preserveSingleSpace() \r\n        output.push(eatString('}')) \r\n      } else if (ch === '{') {\r\n        if (peek(true) === '}') {\r\n          eatWhitespace() \r\n          next() \r\n          print.singleSpace() \r\n          output.push('{}') \r\n          print.newLine() \r\n          if (newline_between_rules && indentLevel === 0) {\r\n            print.newLine(true) \r\n          }\r\n        } else {\r\n          indent() \r\n          print['{'](ch) \r\n          // when entering conditional groups, only rulesets are allowed\r\n          if (enteringConditionalGroup) {\r\n            enteringConditionalGroup = false \r\n            insideRule = (indentLevel > nestedLevel) \r\n          } else {\r\n            // otherwise, declarations are also allowed\r\n            insideRule = (indentLevel >= nestedLevel) \r\n          }\r\n        }\r\n      } else if (ch === '}') {\r\n        outdent() \r\n        print['}'](ch) \r\n        insideRule = false \r\n        insidePropertyValue = false \r\n        if (nestedLevel) {\r\n          nestedLevel-- \r\n        }\r\n        if (newline_between_rules && indentLevel === 0) {\r\n          print.newLine(true) \r\n        }\r\n      } else if (ch === ':') {\r\n        eatWhitespace() \r\n        if ((insideRule || enteringConditionalGroup) &&\r\n                    !(lookBack('&') || foundNestedPseudoClass())) {\r\n          // 'property: value' delimiter\r\n          // which could be in a conditional group query\r\n          insidePropertyValue = true \r\n          output.push(':') \r\n          print.singleSpace() \r\n        } else {\r\n          // sass/less parent reference don't use a space\r\n          // sass nested pseudo-class don't use a space\r\n          if (peek() === ':') {\r\n            // pseudo-element\r\n            next() \r\n            output.push('::') \r\n          } else {\r\n            // pseudo-class\r\n            output.push(':') \r\n          }\r\n        }\r\n      } else if (ch === '\"' || ch === '\\'') {\r\n        print.preserveSingleSpace() \r\n        output.push(eatString(ch)) \r\n      } else if (ch === ' ') {\r\n        insidePropertyValue = false \r\n        output.push(ch) \r\n        print.newLine() \r\n      } else if (ch === '(') { // may be a url\r\n        if (lookBack('url')) {\r\n          output.push(ch) \r\n          eatWhitespace() \r\n          if (next()) {\r\n            if (ch !== ')' && ch !== '\"' && ch !== '\\'') {\r\n              output.push(eatString(')')) \r\n            } else {\r\n              pos-- \r\n            }\r\n          }\r\n        } else {\r\n          parenLevel++ \r\n          print.preserveSingleSpace() \r\n          output.push(ch) \r\n          eatWhitespace() \r\n        }\r\n      } else if (ch === ')') {\r\n        output.push(ch) \r\n        parenLevel-- \r\n      } else if (ch === ',') {\r\n        output.push(ch) \r\n        eatWhitespace() \r\n        if (selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {\r\n          print.newLine() \r\n        } else {\r\n          print.singleSpace() \r\n        }\r\n      } else if (ch === ']') {\r\n        output.push(ch) \r\n      } else if (ch === '[') {\r\n        print.preserveSingleSpace() \r\n        output.push(ch) \r\n      } else if (ch === '=') { // no whitespace before or after\r\n        eatWhitespace()\r\n        ch = '=' \r\n        output.push(ch) \r\n      } else {\r\n        print.preserveSingleSpace() \r\n        output.push(ch) \r\n      }\r\n    }\r\n\r\n\r\n    let sweetCode = '' \r\n    if (basebaseIndentString) {\r\n      sweetCode += basebaseIndentString \r\n    }\r\n\r\n    sweetCode += output.join('').replace(/[\\r\\n\\t ]+$/, '') \r\n\r\n    // establish end_with_newline\r\n    if (end_with_newline) {\r\n      sweetCode += '\\n' \r\n    }\r\n\r\n    if (eol != '\\n') {\r\n      sweetCode = sweetCode.replace(/[\\n]/g, eol) \r\n    }\r\n\r\n    return sweetCode \r\n  }\r\n\r\n  function in_array(what, arr) {\r\n    for (let i = 0 ; i < arr.length;  i += 1) {\r\n      if (arr[i] === what) {\r\n        return true \r\n      }\r\n    }\r\n    return false \r\n  }\r\n\r\n  function trim(s) {\r\n    return s.replace(/^\\s+|\\s+$/g, '') \r\n  }\r\n\r\n  function ltrim(s) {\r\n    return s.replace(/^\\s+/g, '') \r\n  }\r\n\r\n  function rtrim(s) {\r\n    return s.replace(/\\s+$/g, '') \r\n  }\r\n\r\n  function js_beautify(js_source_text, options) {\r\n    'use strict' \r\n    const beautifier = new Beautifier(js_source_text, options) \r\n    return beautifier.beautify() \r\n  }\r\n\r\n  const MODE = {\r\n    BlockStatement: 'BlockStatement', // 'BLOCK'\r\n    Statement: 'Statement', // 'STATEMENT'\r\n    ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\r\n    ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\r\n    ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\r\n    Conditional: 'Conditional', //'(COND-EXPRESSION)',\r\n    Expression: 'Expression' //'(EXPRESSION)'\r\n  } \r\n\r\n  function Beautifier(js_source_text, options) {\r\n    'use strict' \r\n    let output\r\n    let tokens = [], token_pos \r\n    let Tokenizer \r\n    let current_token \r\n    let last_type, last_last_text, indent_string \r\n    let flags, previous_flags, flag_store \r\n    let prefix \r\n\r\n    let handlers, opt \r\n    let baseIndentString = '' \r\n\r\n    handlers = {\r\n      'TK_START_EXPR': handle_start_expr,\r\n      'TK_END_EXPR': handle_end_expr,\r\n      'TK_START_BLOCK': handle_start_block,\r\n      'TK_END_BLOCK': handle_end_block,\r\n      'TK_WORD': handle_word,\r\n      'TK_RESERVED': handle_word,\r\n      'TK_SEMICOLON': handle_semicolon,\r\n      'TK_STRING': handle_string,\r\n      'TK_EQUALS': handle_equals,\r\n      'TK_OPERATOR': handle_operator,\r\n      'TK_COMMA': handle_comma,\r\n      'TK_BLOCK_COMMENT': handle_block_comment,\r\n      'TK_COMMENT': handle_comment,\r\n      'TK_DOT': handle_dot,\r\n      'TK_UNKNOWN': handle_unknown,\r\n      'TK_EOF': handle_eof\r\n    } \r\n\r\n    function create_flags(flags_base, mode) {\r\n      let next_indent_level = 0 \r\n      if (flags_base) {\r\n        next_indent_level = flags_base.indentation_level \r\n        if (!output.just_added_newline() &&\r\n                    flags_base.line_indent_level > next_indent_level) {\r\n          next_indent_level = flags_base.line_indent_level \r\n        }\r\n      }\r\n\r\n      const next_flags = {\r\n        mode: mode,\r\n        parent: flags_base,\r\n        last_text: flags_base ? flags_base.last_text : '', // last token text\r\n        last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed\r\n        declaration_statement: false,\r\n        declaration_assignment: false,\r\n        multiline_frame: false,\r\n        if_block: false,\r\n        else_block: false,\r\n        do_block: false,\r\n        do_while: false,\r\n        in_case_statement: false, // switch(..){ INSIDE HERE }\r\n        in_case: false, // we're on the exact line with \"case 0:\"\r\n        case_body: false, // the indented case-action block\r\n        indentation_level: next_indent_level,\r\n        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\r\n        start_line_index: output.get_line_number(),\r\n        ternary_depth: 0\r\n      } \r\n      return next_flags \r\n    }\r\n\r\n    // Some interpreters have unexpected results with foo = baz || bar \r\n    options = options ? options : {} \r\n    opt = {} \r\n\r\n    // compatibility\r\n    if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\r\n      opt.brace_style = options.braces_on_own_line ? 'expand' : 'collapse' \r\n    }\r\n    opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : 'collapse') \r\n\r\n    // graceful handling of deprecated option\r\n    if (opt.brace_style === 'expand-strict') {\r\n      opt.brace_style = 'expand' \r\n    }\r\n\r\n\r\n    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4 \r\n    opt.indent_char = options.indent_char ? options.indent_char : ' ' \r\n    opt.eol = options.eol ? options.eol : '\\n' \r\n    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines \r\n    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods \r\n    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10) \r\n    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren \r\n    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren \r\n    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy \r\n    opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function \r\n    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation \r\n    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional \r\n    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings \r\n    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10) \r\n    opt.e4x = (options.e4x === undefined) ? false : options.e4x \r\n    opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline \r\n    opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first \r\n\r\n    // For testing of beautify ignore:start directive\r\n    opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw \r\n\r\n    // force opt.space_after_anon_function to true if opt.jslint_happy\r\n    if (opt.jslint_happy) {\r\n      opt.space_after_anon_function = true \r\n    }\r\n\r\n    if (options.indent_with_tabs) {\r\n      opt.indent_char = '\\t' \r\n      opt.indent_size = 1 \r\n    }\r\n\r\n    opt.eol = opt.eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n')\r\n\r\n    //----------------------------------\r\n    indent_string = '' \r\n    while (opt.indent_size > 0) {\r\n      indent_string += opt.indent_char \r\n      opt.indent_size -= 1 \r\n    }\r\n\r\n    let preindent_index = 0 \r\n    if (js_source_text && js_source_text.length) {\r\n      while ((js_source_text.charAt(preindent_index) === ' ' ||\r\n                js_source_text.charAt(preindent_index) === '\\t')) {\r\n        baseIndentString += js_source_text.charAt(preindent_index) \r\n        preindent_index += 1 \r\n      }\r\n      js_source_text = js_source_text.substring(preindent_index) \r\n    }\r\n\r\n    last_type = 'TK_START_BLOCK'  // last token type\r\n    last_last_text = ''  // pre-last token text\r\n    output = new Output(indent_string, baseIndentString) \r\n\r\n    // If testing the ignore directive, start with output disable set to true\r\n    output.raw = opt.test_output_raw \r\n\r\n\r\n    // Stack of parsing/formatting states, including MODE.\r\n    // We tokenize, parse, and output in an almost purely a forward-only stream of token input\r\n    // and formatted output.  This makes the beautifier less accurate than full parsers\r\n    // but also far more tolerant of syntax errors.\r\n    //\r\n    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\r\n    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\r\n    // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \" \",\r\n    // most full parsers would die, but the beautifier gracefully falls back to\r\n    // MODE.BlockStatement and continues on.\r\n    flag_store = [] \r\n    set_mode(MODE.BlockStatement) \r\n\r\n    this.beautify = function () {\r\n\r\n      /*jshint onevar:true */\r\n      let local_token, sweet_code \r\n      Tokenizer = new tokenizer(js_source_text, opt, indent_string) \r\n      tokens = Tokenizer.tokenize() \r\n      token_pos = 0 \r\n\r\n      while (local_token = get_token()) {\r\n        for (let i = 0;  i < local_token.comments_before.length;  i++) {\r\n          // The cleanest handling of inline comments is to treat them as though they aren't there.\r\n          // Just continue formatting and the behavior should be logical.\r\n          // Also ignore unknown tokens.  Again, this should result in better behavior.\r\n          handle_token(local_token.comments_before[i]) \r\n        }\r\n        handle_token(local_token) \r\n\r\n        last_last_text = flags.last_text \r\n        last_type = local_token.type \r\n        flags.last_text = local_token.text \r\n\r\n        token_pos += 1 \r\n      }\r\n\r\n      sweet_code = output.get_code() \r\n      if (opt.end_with_newline) {\r\n        sweet_code += '\\n' \r\n      }\r\n\r\n      if (opt.eol != '\\n') {\r\n        sweet_code = sweet_code.replace(/[\\n]/g, opt.eol) \r\n      }\r\n\r\n      return sweet_code \r\n    } \r\n\r\n    function handle_token(local_token) {\r\n      let { newlines } = local_token \r\n      const keep_whitespace = opt.keep_array_indentation && is_array(flags.mode) \r\n\r\n      if (keep_whitespace) {\r\n        for (let i = 0;  i < newlines;  i += 1) {\r\n          print_newline(i > 0) \r\n        }\r\n      } else {\r\n        if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {\r\n          newlines = opt.max_preserve_newlines \r\n        }\r\n\r\n        if (opt.preserve_newlines) {\r\n          if (local_token.newlines > 1) {\r\n            print_newline() \r\n            for (let i = 1;  i < newlines;  i += 1) {\r\n              print_newline(true) \r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      current_token = local_token \r\n      handlers[current_token.type]() \r\n    }\r\n\r\n    // we could use just string.split, but\r\n    // IE doesn't like returning empty strings\r\n    function split_newlines(s) {\r\n      //return s.split(/\\x0d\\x0a|\\x0a/) \r\n      let idx\r\n      s = s.replace(/\\x0d/g, '') \r\n      const out = []\r\n      idx = s.indexOf('\\n') \r\n      while (idx !== -1) {\r\n        out.push(s.substring(0, idx)) \r\n        s = s.substring(idx + 1) \r\n        idx = s.indexOf('\\n') \r\n      }\r\n      if (s.length) {\r\n        out.push(s) \r\n      }\r\n      return out \r\n    }\r\n\r\n    function allow_wrap_or_preserved_newline(force_linewrap) {\r\n      force_linewrap = (force_linewrap === undefined) ? false : force_linewrap \r\n\r\n      // Never wrap the first token on a line\r\n      if (output.just_added_newline()) {\r\n        return\r\n      }\r\n\r\n      if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {\r\n        print_newline(false, true) \r\n      } else if (opt.wrap_line_length) {\r\n        const proposed_line_length = output.current_line.get_character_count() + current_token.text.length +\r\n                    (output.space_before_token ? 1 : 0) \r\n        if (proposed_line_length >= opt.wrap_line_length) {\r\n          print_newline(false, true) \r\n        }\r\n      }\r\n    }\r\n\r\n    function print_newline(force_newline, preserve_statement_flags) {\r\n      if (!preserve_statement_flags) {\r\n        if (flags.last_text !== ' ' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {\r\n          while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n            restore_mode() \r\n          }\r\n        }\r\n      }\r\n\r\n      if (output.add_new_line(force_newline)) {\r\n        flags.multiline_frame = true \r\n      }\r\n    }\r\n\r\n    function print_token_line_indentation() {\r\n      if (output.just_added_newline()) {\r\n        if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {\r\n          output.current_line.push(current_token.whitespace_before) \r\n          output.space_before_token = false \r\n        } else if (output.set_indent(flags.indentation_level)) {\r\n          flags.line_indent_level = flags.indentation_level \r\n        }\r\n      }\r\n    }\r\n\r\n    function print_token(printable_token) {\r\n      if (output.raw) {\r\n        output.add_raw_token(current_token)\r\n        return \r\n      }\r\n\r\n      if (opt.comma_first && last_type === 'TK_COMMA'\r\n                && output.just_added_newline()) {\r\n        if (output.previous_line.last() === ',') {\r\n          output.previous_line.pop() \r\n          print_token_line_indentation() \r\n          output.add_token(',') \r\n          output.space_before_token = true \r\n        }\r\n      }\r\n\r\n      printable_token = printable_token || current_token.text \r\n      print_token_line_indentation() \r\n      output.add_token(printable_token) \r\n    }\r\n\r\n    function indent() {\r\n      flags.indentation_level += 1 \r\n    }\r\n\r\n    function deindent() {\r\n      if (flags.indentation_level > 0 &&\r\n                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))\r\n        flags.indentation_level -= 1 \r\n    }\r\n\r\n    function set_mode(mode) {\r\n      if (flags) {\r\n        flag_store.push(flags) \r\n        previous_flags = flags \r\n      } else {\r\n        previous_flags = create_flags(null, mode) \r\n      }\r\n\r\n      flags = create_flags(previous_flags, mode) \r\n    }\r\n\r\n    function is_array(mode) {\r\n      return mode === MODE.ArrayLiteral \r\n    }\r\n\r\n    function is_expression(mode) {\r\n      return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]) \r\n    }\r\n\r\n    function restore_mode() {\r\n      if (flag_store.length > 0) {\r\n        previous_flags = flags \r\n        flags = flag_store.pop() \r\n        if (previous_flags.mode === MODE.Statement) {\r\n          output.remove_redundant_indentation(previous_flags) \r\n        }\r\n      }\r\n    }\r\n\r\n    function start_of_object_property() {\r\n      return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (\r\n        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))) \r\n    }\r\n\r\n    function start_of_statement() {\r\n      if (\r\n        (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['const', 'let', 'const']) && current_token.type === 'TK_WORD') ||\r\n                (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||\r\n                (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||\r\n                (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||\r\n                (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||\r\n                (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement\r\n                    && !flags.in_case\r\n                    && !(current_token.text === '--' || current_token.text === '++')\r\n                    && last_last_text !== 'function'\r\n                    && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||\r\n                (flags.mode === MODE.ObjectLiteral && (\r\n                  (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))\r\n      ) {\r\n\r\n        set_mode(MODE.Statement) \r\n        indent() \r\n\r\n        if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['const', 'let', 'const']) && current_token.type === 'TK_WORD') {\r\n          flags.declaration_statement = true \r\n        }\r\n\r\n        // Issue #276:\r\n        // If starting a new statement with [if, for, while, do], push to a new line.\r\n        // if (a) if (b) if(c) d()  else e()  else f() \r\n        if (!start_of_object_property()) {\r\n          allow_wrap_or_preserved_newline(\r\n            current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while'])) \r\n        }\r\n\r\n        return true \r\n      }\r\n      return false \r\n    }\r\n\r\n    function all_lines_start_with(lines, c) {\r\n      for (let i = 0;  i < lines.length;  i++) {\r\n        const line = trim(lines[i]) \r\n        if (line.charAt(0) !== c) {\r\n          return false \r\n        }\r\n      }\r\n      return true \r\n    }\r\n\r\n    function each_line_matches_indent(lines, indent) {\r\n      let i = 0,\r\n        len = lines.length,\r\n        line \r\n      for ( ; i < len;  i++) {\r\n        line = lines[i] \r\n        // allow empty lines to pass through\r\n        if (line && line.indexOf(indent) !== 0) {\r\n          return false \r\n        }\r\n      }\r\n      return true \r\n    }\r\n\r\n    function is_special_word(word) {\r\n      return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']) \r\n    }\r\n\r\n    function get_token(offset) {\r\n      const index = token_pos + (offset || 0) \r\n      return (index < 0 || index >= tokens.length) ? null : tokens[index] \r\n    }\r\n\r\n    function handle_start_expr() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n      }\r\n\r\n      let next_mode = MODE.Expression \r\n      if (current_token.text === '[') {\r\n\r\n        if (last_type === 'TK_WORD' || flags.last_text === ')') {\r\n          // this is array index specifier, break immediately\r\n          // a[x], fn()[x]\r\n          if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {\r\n            output.space_before_token = true \r\n          }\r\n          set_mode(next_mode) \r\n          print_token() \r\n          indent() \r\n          if (opt.space_in_paren) {\r\n            output.space_before_token = true \r\n          }\r\n          return \r\n        }\r\n\r\n        next_mode = MODE.ArrayLiteral \r\n        if (is_array(flags.mode)) {\r\n          if (flags.last_text === '[' ||\r\n                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {\r\n            // ], [ goes to new line\r\n            // }, [ goes to new line\r\n            if (!opt.keep_array_indentation) {\r\n              print_newline() \r\n            }\r\n          }\r\n        }\r\n\r\n      } else {\r\n        if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {\r\n          next_mode = MODE.ForInitializer \r\n        } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {\r\n          next_mode = MODE.Conditional \r\n        } else {\r\n          // next_mode = MODE.Expression \r\n        }\r\n      }\r\n\r\n      if (flags.last_text === ' ' || last_type === 'TK_START_BLOCK') {\r\n        print_newline() \r\n      } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {\r\n        // TODO: Consider whether forcing this is required.  Review failing tests when removed.\r\n        allow_wrap_or_preserved_newline(current_token.wanted_newline) \r\n        // do nothing on (( and )( and ][ and ]( and .(\r\n      } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\r\n        output.space_before_token = true \r\n      } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n        // function() vs function ()\r\n        if (opt.space_after_anon_function) {\r\n          output.space_before_token = true \r\n        }\r\n      } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {\r\n        if (opt.space_before_conditional) {\r\n          output.space_before_token = true \r\n        }\r\n      }\r\n\r\n      // Should be a space between await and an IIFE\r\n      if (current_token.text === '(' && last_type === 'TK_RESERVED' && flags.last_word === 'await') {\r\n        output.space_before_token = true \r\n      }\r\n\r\n      // Support of this kind of newline preservation.\r\n      // a = (b &&\r\n      //     (c || d)) \r\n      if (current_token.text === '(') {\r\n        if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n          if (!start_of_object_property()) {\r\n            allow_wrap_or_preserved_newline() \r\n          }\r\n        }\r\n      }\r\n\r\n      set_mode(next_mode) \r\n      print_token() \r\n      if (opt.space_in_paren) {\r\n        output.space_before_token = true \r\n      }\r\n\r\n      // In all cases, if we newline while inside an expression it should be indented.\r\n      indent() \r\n    }\r\n\r\n    function handle_end_expr() {\r\n      // statements inside expressions are not valid syntax, but...\r\n      // statements must all be closed when their container closes\r\n      while (flags.mode === MODE.Statement) {\r\n        restore_mode() \r\n      }\r\n\r\n      if (flags.multiline_frame) {\r\n        allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation) \r\n      }\r\n\r\n      if (opt.space_in_paren) {\r\n        if (last_type === 'TK_START_EXPR' && !opt.space_in_empty_paren) {\r\n          // () [] no inner space in empty parens like these, ever, ref #320\r\n          output.trim() \r\n          output.space_before_token = false \r\n        } else {\r\n          output.space_before_token = true \r\n        }\r\n      }\r\n      if (current_token.text === ']' && opt.keep_array_indentation) {\r\n        print_token() \r\n        restore_mode() \r\n      } else {\r\n        restore_mode() \r\n        print_token() \r\n      }\r\n      output.remove_redundant_indentation(previous_flags) \r\n\r\n      // do {} while () // no statement required after\r\n      if (flags.do_while && previous_flags.mode === MODE.Conditional) {\r\n        previous_flags.mode = MODE.Expression \r\n        flags.do_block = false \r\n        flags.do_while = false \r\n\r\n      }\r\n    }\r\n\r\n    function handle_start_block() {\r\n      // Check if this is should be treated as a ObjectLiteral\r\n      const next_token = get_token(1)\r\n      const second_token = get_token(2)\r\n      if (second_token && (\r\n        (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))\r\n                || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))\r\n      )) {\r\n        // We don't support TypeScript,but we didn't break it for a very long time.\r\n        // We'll try to keep not breaking it.\r\n        if (!in_array(last_last_text, ['class', 'interface'])) {\r\n          set_mode(MODE.ObjectLiteral) \r\n        } else {\r\n          set_mode(MODE.BlockStatement) \r\n        }\r\n      } else {\r\n        set_mode(MODE.BlockStatement) \r\n      }\r\n\r\n      const empty_braces = !next_token.comments_before.length && next_token.text === '}' \r\n      const empty_anonymous_function = empty_braces && flags.last_word === 'function' &&\r\n                last_type === 'TK_END_EXPR' \r\n\r\n      if (opt.brace_style === 'expand' ||\r\n                (opt.brace_style === 'none' && current_token.wanted_newline)) {\r\n        if (last_type !== 'TK_OPERATOR' &&\r\n                    (empty_anonymous_function ||\r\n                        last_type === 'TK_EQUALS' ||\r\n                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {\r\n          output.space_before_token = true \r\n        } else {\r\n          print_newline(false, true) \r\n        }\r\n      } else { // collapse\r\n        if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\r\n          if (last_type === 'TK_START_BLOCK') {\r\n            print_newline() \r\n          } else {\r\n            output.space_before_token = true \r\n          }\r\n        } else {\r\n          // if TK_OPERATOR or TK_START_EXPR\r\n          if (is_array(previous_flags.mode) && flags.last_text === ',') {\r\n            if (last_last_text === '}') {\r\n              // }, { in array context\r\n              output.space_before_token = true \r\n            } else {\r\n              print_newline()  // [a, b, c, {\r\n            }\r\n          }\r\n        }\r\n      }\r\n      print_token() \r\n      indent() \r\n    }\r\n\r\n    function handle_end_block() {\r\n      // statements must all be closed when their container closes\r\n      while (flags.mode === MODE.Statement) {\r\n        restore_mode() \r\n      }\r\n      const empty_braces = last_type === 'TK_START_BLOCK' \r\n\r\n      if (opt.brace_style === 'expand') {\r\n        if (!empty_braces) {\r\n          print_newline() \r\n        }\r\n      } else {\r\n        // skip {}\r\n        if (!empty_braces) {\r\n          if (is_array(flags.mode) && opt.keep_array_indentation) {\r\n            // we REALLY need a newline here, but newliner would skip that\r\n            opt.keep_array_indentation = false \r\n            print_newline() \r\n            opt.keep_array_indentation = true \r\n\r\n          } else {\r\n            print_newline() \r\n          }\r\n        }\r\n      }\r\n      restore_mode() \r\n      print_token() \r\n    }\r\n\r\n    function handle_word() {\r\n      if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&\r\n                in_array(current_token.text, ['set', 'get'])) {\r\n        current_token.type = 'TK_WORD' \r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {\r\n        const next_token = get_token(1) \r\n        if (next_token.text === ':') {\r\n          current_token.type = 'TK_WORD' \r\n        }\r\n      }\r\n\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n      } else if (current_token.wanted_newline && !is_expression(flags.mode) &&\r\n                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&\r\n                last_type !== 'TK_EQUALS' &&\r\n                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['const', 'let', 'const', 'set', 'get'])))) {\r\n\r\n        print_newline() \r\n      }\r\n\r\n      if (flags.do_block && !flags.do_while) {\r\n        if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {\r\n          // do {} ## while ()\r\n          output.space_before_token = true \r\n          print_token() \r\n          output.space_before_token = true \r\n          flags.do_while = true \r\n          return \r\n        } else {\r\n          // do {} should always have while as the next word.\r\n          // if we don't see the expected while, recover\r\n          print_newline() \r\n          flags.do_block = false \r\n        }\r\n      }\r\n\r\n      // if may be followed by else, or not\r\n      // Bare/inline ifs are tricky\r\n      // Need to unwind the modes correctly: if (a) if (b) c()  else d()  else e() \r\n      if (flags.if_block) {\r\n        if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {\r\n          flags.else_block = true \r\n        } else {\r\n          while (flags.mode === MODE.Statement) {\r\n            restore_mode() \r\n          }\r\n          flags.if_block = false \r\n          flags.else_block = false \r\n        }\r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {\r\n        print_newline() \r\n        if (flags.case_body || opt.jslint_happy) {\r\n          // switch cases following one another\r\n          deindent() \r\n          flags.case_body = false \r\n        }\r\n        print_token() \r\n        flags.in_case = true \r\n        flags.in_case_statement = true \r\n        return \r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {\r\n        if (in_array(flags.last_text, ['}', ' ']) || (output.just_added_newline() && !in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {\r\n          // make sure there is a nice clean space of at least one blank line\r\n          // before a new function definition\r\n          if (!output.just_added_blankline() && !current_token.comments_before.length) {\r\n            print_newline() \r\n            print_newline(true) \r\n          }\r\n        }\r\n        if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n          if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export', 'async'])) {\r\n            output.space_before_token = true \r\n          } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {\r\n            output.space_before_token = true \r\n          } else {\r\n            print_newline() \r\n          }\r\n        } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {\r\n          // foo = function\r\n          output.space_before_token = true \r\n        } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {\r\n          // (function\r\n        } else {\r\n          print_newline() \r\n        }\r\n      }\r\n\r\n      if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n        if (!start_of_object_property()) {\r\n          allow_wrap_or_preserved_newline() \r\n        }\r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['function', 'get', 'set'])) {\r\n        print_token() \r\n        flags.last_word = current_token.text \r\n        return \r\n      }\r\n\r\n      prefix = 'NONE' \r\n\r\n      if (last_type === 'TK_END_BLOCK') {\r\n        if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {\r\n          prefix = 'NEWLINE' \r\n        } else {\r\n          if (opt.brace_style === 'expand' ||\r\n                        opt.brace_style === 'end-expand' ||\r\n                        (opt.brace_style === 'none' && current_token.wanted_newline)) {\r\n            prefix = 'NEWLINE' \r\n          } else {\r\n            prefix = 'SPACE' \r\n            output.space_before_token = true \r\n          }\r\n        }\r\n      } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {\r\n        // TODO: Should this be for STATEMENT as well?\r\n        prefix = 'NEWLINE' \r\n      } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\r\n        prefix = 'SPACE' \r\n      } else if (last_type === 'TK_STRING') {\r\n        prefix = 'NEWLINE' \r\n      } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n        prefix = 'SPACE' \r\n      } else if (last_type === 'TK_START_BLOCK') {\r\n        prefix = 'NEWLINE' \r\n      } else if (last_type === 'TK_END_EXPR') {\r\n        output.space_before_token = true \r\n        prefix = 'NEWLINE' \r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n        if (flags.last_text === 'else' || flags.last_text === 'export') {\r\n          prefix = 'SPACE' \r\n        } else {\r\n          prefix = 'NEWLINE' \r\n        }\r\n\r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {\r\n        if (last_type !== 'TK_END_BLOCK' ||\r\n                    opt.brace_style === 'expand' ||\r\n                    opt.brace_style === 'end-expand' ||\r\n                    (opt.brace_style === 'none' && current_token.wanted_newline)) {\r\n          print_newline() \r\n        } else {\r\n          output.trim(true) \r\n          const line = output.current_line \r\n          // If we trimmed and there's something other than a close block before us\r\n          // put a newline back in.  Handles '} // comment' scenario.\r\n          if (line.last() !== '}') {\r\n            print_newline() \r\n          }\r\n          output.space_before_token = true \r\n        }\r\n      } else if (prefix === 'NEWLINE') {\r\n        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n          // no newline between 'return nnn'\r\n          output.space_before_token = true \r\n        } else if (last_type !== 'TK_END_EXPR') {\r\n          if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['const', 'let', 'const']))) && flags.last_text !== ':') {\r\n            // no need to force newline on 'const': for (const x = 0...)\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {\r\n              // no newline for } else if {\r\n              output.space_before_token = true \r\n            } else {\r\n              print_newline() \r\n            }\r\n          }\r\n        } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n          print_newline() \r\n        }\r\n      } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {\r\n        print_newline()  // }, in lists get a newline treatment\r\n      } else if (prefix === 'SPACE') {\r\n        output.space_before_token = true \r\n      }\r\n      print_token() \r\n      flags.last_word = current_token.text \r\n\r\n      if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {\r\n        flags.do_block = true \r\n      }\r\n\r\n      if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {\r\n        flags.if_block = true \r\n      }\r\n    }\r\n\r\n    function handle_semicolon() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n        // Semicolon can be the start (and end) of a statement\r\n        output.space_before_token = false \r\n      }\r\n      while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n        restore_mode() \r\n      }\r\n      print_token() \r\n    }\r\n\r\n    function handle_string() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n        // One difference - strings want at least a space before\r\n        output.space_before_token = true \r\n      } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n        output.space_before_token = true \r\n      } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n        if (!start_of_object_property()) {\r\n          allow_wrap_or_preserved_newline() \r\n        }\r\n      } else {\r\n        print_newline() \r\n      }\r\n      print_token() \r\n    }\r\n\r\n    function handle_equals() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n      }\r\n\r\n      if (flags.declaration_statement) {\r\n        // just got an '=' in a const-line, different formatting/line-breaking, etc will now be done\r\n        flags.declaration_assignment = true \r\n      }\r\n      output.space_before_token = true \r\n      print_token() \r\n      output.space_before_token = true \r\n    }\r\n\r\n    function handle_comma() {\r\n      if (flags.declaration_statement) {\r\n        if (is_expression(flags.parent.mode)) {\r\n          // do not break on comma, for(const a = 1, b = 2)\r\n          flags.declaration_assignment = false \r\n        }\r\n\r\n        print_token() \r\n\r\n        if (flags.declaration_assignment) {\r\n          flags.declaration_assignment = false \r\n          print_newline(false, true) \r\n        } else {\r\n          output.space_before_token = true \r\n          // for comma-first, we want to allow a newline before the comma\r\n          // to turn into a newline after the comma, which we will fixup later\r\n          if (opt.comma_first) {\r\n            allow_wrap_or_preserved_newline() \r\n          }\r\n        }\r\n        return \r\n      }\r\n\r\n      print_token() \r\n      if (flags.mode === MODE.ObjectLiteral ||\r\n                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {\r\n        if (flags.mode === MODE.Statement) {\r\n          restore_mode() \r\n        }\r\n        print_newline() \r\n      } else {\r\n        // EXPR or DO_BLOCK\r\n        output.space_before_token = true \r\n        // for comma-first, we want to allow a newline before the comma\r\n        // to turn into a newline after the comma, which we will fixup later\r\n        if (opt.comma_first) {\r\n          allow_wrap_or_preserved_newline() \r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    function handle_operator() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n      }\r\n\r\n      if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n        // \"return\" had a special handling in TK_WORD. Now we need to return the favor\r\n        output.space_before_token = true \r\n        print_token() \r\n        return \r\n      }\r\n\r\n      // hack for actionscript's import .* \r\n      if (current_token.text === '*' && last_type === 'TK_DOT') {\r\n        print_token() \r\n        return \r\n      }\r\n\r\n      if (current_token.text === ':' && flags.in_case) {\r\n        flags.case_body = true \r\n        indent() \r\n        print_token() \r\n        print_newline() \r\n        flags.in_case = false \r\n        return \r\n      }\r\n\r\n      if (current_token.text === '::') {\r\n        // no spaces around exotic namespacing syntax operator\r\n        print_token() \r\n        return \r\n      }\r\n\r\n      // Allow line wrapping between operators\r\n      if (last_type === 'TK_OPERATOR') {\r\n        allow_wrap_or_preserved_newline() \r\n      }\r\n\r\n      let space_before = true \r\n      let space_after = true \r\n\r\n      if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {\r\n        // unary operators (and binary +/- pretending to be unary) special cases\r\n\r\n        space_before = false \r\n        space_after = false \r\n\r\n        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\r\n        // if there is a newline between -- or ++ and anything else we should preserve it.\r\n        if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {\r\n          print_newline(false, true) \r\n        }\r\n\r\n        if (flags.last_text === ' ' && is_expression(flags.mode)) {\r\n          // for (   ++i)\r\n          //        ^^^\r\n          space_before = true \r\n        }\r\n\r\n        if (last_type === 'TK_RESERVED') {\r\n          space_before = true \r\n        } else if (last_type === 'TK_END_EXPR') {\r\n          space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++')) \r\n        } else if (last_type === 'TK_OPERATOR') {\r\n          // a++ + ++b \r\n          // a - -b\r\n          space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']) \r\n          // + and - are not unary when preceeded by -- or ++ operator\r\n          // a-- + b\r\n          // a * +b\r\n          // a - -b\r\n          if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {\r\n            space_after = true \r\n          }\r\n        }\r\n\r\n        if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ' ')) {\r\n          // { foo  --i }\r\n          // foo()  --bar \r\n          print_newline() \r\n        }\r\n      } else if (current_token.text === ':') {\r\n        if (flags.ternary_depth === 0) {\r\n          // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\r\n          space_before = false \r\n        } else {\r\n          flags.ternary_depth -= 1 \r\n        }\r\n      } else if (current_token.text === '?') {\r\n        flags.ternary_depth += 1 \r\n      } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {\r\n        space_before = false \r\n        space_after = false \r\n      }\r\n      output.space_before_token = output.space_before_token || space_before \r\n      print_token() \r\n      output.space_before_token = space_after \r\n    }\r\n\r\n    function handle_block_comment() {\r\n      if (output.raw) {\r\n        output.add_raw_token(current_token)\r\n        if (current_token.directives && current_token.directives['preserve'] === 'end') {\r\n          // If we're testing the raw output behavior, do not allow a directive to turn it off.\r\n          if (!opt.test_output_raw) {\r\n            output.raw = false \r\n          }\r\n        }\r\n        return \r\n      }\r\n\r\n      if (current_token.directives) {\r\n        print_newline(false, true) \r\n        print_token() \r\n        if (current_token.directives['preserve'] === 'start') {\r\n          output.raw = true \r\n        }\r\n        print_newline(false, true) \r\n        return \r\n      }\r\n\r\n      // inline block\r\n      if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {\r\n        output.space_before_token = true \r\n        print_token() \r\n        output.space_before_token = true \r\n        return \r\n      }\r\n\r\n      const lines = split_newlines(current_token.text) \r\n      let j  // iterator for this case\r\n      let javadoc = false \r\n      let starless = false \r\n      const { whitespace_before : lastIndent } = current_token \r\n      const { length : lastIndentLength } = lastIndent \r\n\r\n      // block comment starts with a new line\r\n      print_newline(false, true) \r\n      if (lines.length > 1) {\r\n        if (all_lines_start_with(lines.slice(1), '*')) {\r\n          javadoc = true \r\n        }\r\n        else if (each_line_matches_indent(lines.slice(1), lastIndent)) {\r\n          starless = true \r\n        }\r\n      }\r\n\r\n      // first line always indented\r\n      print_token(lines[0]) \r\n      for (j = 1;  j < lines.length;  j++) {\r\n        print_newline(false, true) \r\n        if (javadoc) {\r\n          // javadoc: reformat and re-indent\r\n          print_token(` ${ltrim(lines[j])}`) \r\n        } else if (starless && lines[j].length > lastIndentLength) {\r\n          // starless: re-indent non-empty content, avoiding trim\r\n          print_token(lines[j].substring(lastIndentLength)) \r\n        } else {\r\n          // normal comments output raw\r\n          output.add_token(lines[j]) \r\n        }\r\n      }\r\n\r\n      // for comments of more than one line, make sure there's a new line after\r\n      print_newline(false, true) \r\n    }\r\n\r\n    function handle_comment() {\r\n      if (current_token.wanted_newline) {\r\n        print_newline(false, true) \r\n      } else {\r\n        output.trim(true) \r\n      }\r\n\r\n      output.space_before_token = true \r\n      print_token() \r\n      print_newline(false, true) \r\n    }\r\n\r\n    function handle_dot() {\r\n      if (start_of_statement()) {\r\n        // The conditional starts the statement if appropriate.\r\n      }\r\n\r\n      if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n        output.space_before_token = true \r\n      } else {\r\n        // allow preserved newlines before dots in general\r\n        // force newlines on dots after close paren when break_chained - for bar().baz()\r\n        allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods) \r\n      }\r\n\r\n      print_token() \r\n    }\r\n\r\n    function handle_unknown() {\r\n      print_token() \r\n\r\n      if (current_token.text[current_token.text.length - 1] === '\\n') {\r\n        print_newline() \r\n      }\r\n    }\r\n\r\n    function handle_eof() {\r\n      // Unwind any open statements\r\n      while (flags.mode === MODE.Statement) {\r\n        restore_mode() \r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  function OutputLine(parent) {\r\n    let _character_count = 0 \r\n    // use indent_count as a marker for lines that have preserved indentation\r\n    let _indent_count = -1 \r\n\r\n    const _items = [] \r\n    let _empty = true \r\n\r\n    this.set_indent = function (level) {\r\n      _character_count = parent.baseIndentLength + level * parent.indent_length\r\n      _indent_count = level \r\n    }\r\n\r\n    this.get_character_count = function () {\r\n      return _character_count \r\n    }\r\n\r\n    this.is_empty = function () {\r\n      return _empty \r\n    }\r\n\r\n    this.last = function () {\r\n      if (!this._empty) {\r\n        return _items[_items.length - 1] \r\n      } else {\r\n        return null \r\n      }\r\n    }\r\n\r\n    this.push = function (input) {\r\n      _items.push(input) \r\n      _character_count += input.length \r\n      _empty = false \r\n    }\r\n\r\n    this.pop = function () {\r\n      let item = null \r\n      if (!_empty) {\r\n        item = _items.pop() \r\n        _character_count -= item.length \r\n        _empty = _items.length === 0 \r\n      }\r\n      return item \r\n    }\r\n\r\n    this.remove_indent = function () {\r\n      if (_indent_count > 0) {\r\n        _indent_count -= 1 \r\n        _character_count -= parent.indent_length\r\n      }\r\n    }\r\n\r\n    this.trim = function () {\r\n      while (this.last() === ' ') {\r\n        _items.pop() \r\n        _character_count -= 1 \r\n      }\r\n      _empty = _items.length === 0 \r\n    }\r\n\r\n    this.toString = function () {\r\n      let result = '' \r\n      if (!this._empty) {\r\n        if (_indent_count >= 0) {\r\n          result = parent.indent_cache[_indent_count] \r\n        }\r\n        result += _items.join('')\r\n      }\r\n      return result \r\n    }\r\n  }\r\n\r\n  function Output(indent_string, baseIndentString) {\r\n    baseIndentString = baseIndentString || '' \r\n    this.indent_cache = [baseIndentString] \r\n    this.baseIndentLength = baseIndentString.length \r\n    this.indent_length = indent_string.length \r\n    this.raw = false \r\n\r\n    const lines = [] \r\n    this.baseIndentString = baseIndentString \r\n    this.indent_string = indent_string \r\n    this.previous_line = null \r\n    this.current_line = null \r\n    this.space_before_token = false \r\n\r\n    this.add_outputline = function () {\r\n      this.previous_line = this.current_line \r\n      this.current_line = new OutputLine(this) \r\n      lines.push(this.current_line) \r\n    }\r\n\r\n    // initialize\r\n    this.add_outputline() \r\n\r\n\r\n    this.get_line_number = function () {\r\n      return lines.length \r\n    }\r\n\r\n    // Using object instead of string to allow for later expansion of info about each line\r\n    this.add_new_line = function (force_newline) {\r\n      if (this.get_line_number() === 1 && this.just_added_newline()) {\r\n        return false  // no newline on start of file\r\n      }\r\n\r\n      if (force_newline || !this.just_added_newline()) {\r\n        if (!this.raw) {\r\n          this.add_outputline() \r\n        }\r\n        return true \r\n      }\r\n\r\n      return false \r\n    }\r\n\r\n    this.get_code = function () {\r\n      const sweet_code = lines.join('\\n').replace(/[\\r\\n\\t ]+$/, '') \r\n      return sweet_code \r\n    }\r\n\r\n    this.set_indent = function (level) {\r\n      // Never indent your first output indent at the start of the file\r\n      if (lines.length > 1) {\r\n        while (level >= this.indent_cache.length) {\r\n          this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string) \r\n        }\r\n\r\n        this.current_line.set_indent(level) \r\n        return true \r\n      }\r\n      this.current_line.set_indent(0) \r\n      return false \r\n    }\r\n\r\n    this.add_raw_token = function (token) {\r\n      for (let x = 0;  x < token.newlines;  x++) {\r\n        this.add_outputline() \r\n      }\r\n      this.current_line.push(token.whitespace_before) \r\n      this.current_line.push(token.text) \r\n      this.space_before_token = false \r\n    }\r\n\r\n    this.add_token = function (printable_token) {\r\n      this.add_space_before_token() \r\n      this.current_line.push(printable_token) \r\n    }\r\n\r\n    this.add_space_before_token = function () {\r\n      if (this.space_before_token && !this.just_added_newline()) {\r\n        this.current_line.push(' ') \r\n      }\r\n      this.space_before_token = false \r\n    }\r\n\r\n    this.remove_redundant_indentation = function (frame) {\r\n      // This implementation is effective but has some issues:\r\n      //     - can cause line wrap to happen too soon due to indent removal\r\n      //           after wrap points are calculated\r\n      // These issues are minor compared to ugly indentation.\r\n\r\n      if (frame.multiline_frame ||\r\n                frame.mode === MODE.ForInitializer ||\r\n                frame.mode === MODE.Conditional) {\r\n        return \r\n      }\r\n\r\n      // remove one indent from each line inside this section\r\n      let index = frame.start_line_index \r\n      \r\n      const output_length = lines.length \r\n      while (index < output_length) {\r\n        lines[index].remove_indent() \r\n        index++ \r\n      }\r\n    }\r\n\r\n    this.trim = function (eat_newlines) {\r\n      eat_newlines = (eat_newlines === undefined) ? false : eat_newlines \r\n\r\n      this.current_line.trim(indent_string, baseIndentString) \r\n\r\n      while (eat_newlines && lines.length > 1 &&\r\n                this.current_line.is_empty()) {\r\n        lines.pop() \r\n        this.current_line = lines[lines.length - 1]\r\n        this.current_line.trim() \r\n      }\r\n\r\n      this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null \r\n    }\r\n\r\n    this.just_added_newline = function () {\r\n      return this.current_line.is_empty() \r\n    }\r\n\r\n    this.just_added_blankline = function () {\r\n      if (this.just_added_newline()) {\r\n        if (lines.length === 1) {\r\n          return true  // start of the file and newline = blank\r\n        }\r\n\r\n        const line = lines[lines.length - 2] \r\n        return line.is_empty() \r\n      }\r\n      return false \r\n    }\r\n  }\r\n\r\n\r\n  const Token = function (type, text, newlines, whitespace_before, mode, parent) {\r\n    this.type = type \r\n    this.text = text \r\n    this.comments_before = [] \r\n    this.newlines = newlines || 0 \r\n    this.wanted_newline = newlines > 0 \r\n    this.whitespace_before = whitespace_before || '' \r\n    this.parent = null \r\n    this.directives = null \r\n  }\r\n\r\n  function tokenizer(input, opts, indent_string) {\r\n\r\n    const whitespace = '\\n\\r\\t '.split('') \r\n    const digit = /[0-9]/ \r\n    const digit_oct = /[01234567]/ \r\n    const digit_hex = /[0123456789abcdefABCDEF]/ \r\n\r\n    const punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>').split(' ') \r\n    // words which should always start on new line.\r\n    this.line_starters = 'continue,try,throw,return,const,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',') \r\n    const reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await']) \r\n\r\n    //  /* ... */ comment ends with nearest */ or end of file\r\n    const block_comment_pattern = /([\\s\\S]*?)((?:\\*\\/)|$)/g \r\n\r\n    // comment ends just before nearest linefeed or end of file\r\n    const comment_pattern = /([^\\n\\r\\u2028\\u2029]*)/g \r\n\r\n    const directives_block_pattern = /\\/\\* beautify( \\w+[:]\\w+)+ \\*\\//g \r\n    const directive_pattern = / (\\w+)[:](\\w+)/g \r\n    const directives_end_ignore_pattern = /([\\s\\S]*?)((?:\\/\\*\\sbeautify\\signore:end\\s\\*\\/)|$)/g \r\n\r\n    const template_pattern = /((<\\?php|<\\?=)[\\s\\S]*?\\?>)|(<%[\\s\\S]*?%>)/g\r\n\r\n    let n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos \r\n    let input_length \r\n\r\n    this.tokenize = function () {\r\n      // cache the source's length.\r\n      input_length = input.length\r\n      parser_pos = 0 \r\n      in_html_comment = false\r\n      tokens = [] \r\n\r\n      let next, last \r\n      let token_values \r\n      let open = null \r\n      const open_stack = [] \r\n      let comments = [] \r\n\r\n      while (!(last && last.type === 'TK_EOF')) {\r\n        token_values = tokenize_next() \r\n        next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token) \r\n        while (next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {\r\n          if (next.type === 'TK_BLOCK_COMMENT') {\r\n            next.directives = token_values[2] \r\n          }\r\n          comments.push(next) \r\n          token_values = tokenize_next() \r\n          next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token) \r\n        }\r\n\r\n        if (comments.length) {\r\n          next.comments_before = comments \r\n          comments = [] \r\n        }\r\n\r\n        if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {\r\n          next.parent = last \r\n          open_stack.push(open) \r\n          open = next \r\n        } else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&\r\n                    (open && (\r\n                      (next.text === ']' && open.text === '[') ||\r\n                        (next.text === ')' && open.text === '(') ||\r\n                        (next.text === '}' && open.text === '{')))) {\r\n          next.parent = open.parent \r\n          open = open_stack.pop() \r\n        }\r\n\r\n        tokens.push(next) \r\n        last = next \r\n      }\r\n\r\n      return tokens \r\n    }\r\n\r\n    function get_directives(text) {\r\n      if (!text.match(directives_block_pattern)) {\r\n        return null \r\n      }\r\n\r\n      const directives = {} \r\n      directive_pattern.lastIndex = 0 \r\n      let directive_match = directive_pattern.exec(text) \r\n\r\n      while (directive_match) {\r\n        directives[directive_match[1]] = directive_match[2] \r\n        directive_match = directive_pattern.exec(text) \r\n      }\r\n\r\n      return directives \r\n    }\r\n\r\n    function tokenize_next() {\r\n      let resulting_string \r\n      let whitespace_on_this_line = [] \r\n\r\n      n_newlines = 0 \r\n      whitespace_before_token = '' \r\n\r\n      if (parser_pos >= input_length) {\r\n        return ['', 'TK_EOF'] \r\n      }\r\n\r\n      let last_token \r\n      if (tokens.length) {\r\n        last_token = tokens[tokens.length - 1] \r\n      } else {\r\n        // For the sake of tokenizing we can pretend that there was on open brace to start\r\n        last_token = new Token('TK_START_BLOCK', '{') \r\n      }\r\n\r\n\r\n      let c = input.charAt(parser_pos) \r\n      parser_pos += 1 \r\n\r\n      while (in_array(c, whitespace)) {\r\n\r\n        if (acorn.newline.test(c)) {\r\n          if (!(c === '\\n' && input.charAt(parser_pos - 2) === '\\r')) {\r\n            n_newlines += 1 \r\n            whitespace_on_this_line = [] \r\n          }\r\n        } else {\r\n          whitespace_on_this_line.push(c) \r\n        }\r\n\r\n        if (parser_pos >= input_length) {\r\n          return ['', 'TK_EOF'] \r\n        }\r\n\r\n        c = input.charAt(parser_pos) \r\n        parser_pos += 1 \r\n      }\r\n\r\n      if (whitespace_on_this_line.length) {\r\n        whitespace_before_token = whitespace_on_this_line.join('') \r\n      }\r\n\r\n      if (digit.test(c)) {\r\n        let allow_decimal = true \r\n        let allow_e = true \r\n        let local_digit = digit \r\n\r\n        if (c === '0' && parser_pos < input_length && /[Xxo]/.test(input.charAt(parser_pos))) {\r\n          // switch to hex/oct number, no decimal or e, just hex/oct digits\r\n          allow_decimal = false \r\n          allow_e = false \r\n          c += input.charAt(parser_pos) \r\n          parser_pos += 1 \r\n          local_digit = /[o]/.test(input.charAt(parser_pos)) ? digit_oct : digit_hex \r\n        } else {\r\n          // we know this first loop will run.  It keeps the logic simpler.\r\n          c = '' \r\n          parser_pos -= 1 \r\n        }\r\n\r\n        // Add the digits\r\n        while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {\r\n          c += input.charAt(parser_pos) \r\n          parser_pos += 1 \r\n\r\n          if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {\r\n            c += input.charAt(parser_pos) \r\n            parser_pos += 1 \r\n            allow_decimal = false \r\n          }\r\n\r\n          if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {\r\n            c += input.charAt(parser_pos) \r\n            parser_pos += 1 \r\n\r\n            if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {\r\n              c += input.charAt(parser_pos) \r\n              parser_pos += 1 \r\n            }\r\n\r\n            allow_e = false \r\n            allow_decimal = false \r\n          }\r\n        }\r\n\r\n        return [c, 'TK_WORD'] \r\n      }\r\n\r\n      if (acorn.isIdentifierStart(input.charCodeAt(parser_pos - 1))) {\r\n        if (parser_pos < input_length) {\r\n          while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {\r\n            c += input.charAt(parser_pos) \r\n            parser_pos += 1 \r\n            if (parser_pos === input_length) {\r\n              break \r\n            }\r\n          }\r\n        }\r\n\r\n        if (!(last_token.type === 'TK_DOT' ||\r\n                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))\r\n                    && in_array(c, reserved_words)) {\r\n          if (c === 'in') { // hack for 'in' operator\r\n            return [c, 'TK_OPERATOR'] \r\n          }\r\n          return [c, 'TK_RESERVED'] \r\n        }\r\n\r\n        return [c, 'TK_WORD'] \r\n      }\r\n\r\n      if (c === '(' || c === '[') {\r\n        return [c, 'TK_START_EXPR'] \r\n      }\r\n\r\n      if (c === ')' || c === ']') {\r\n        return [c, 'TK_END_EXPR'] \r\n      }\r\n\r\n      if (c === '{') {\r\n        return [c, 'TK_START_BLOCK'] \r\n      }\r\n\r\n      if (c === '}') {\r\n        return [c, 'TK_END_BLOCK'] \r\n      }\r\n\r\n      if (c === ' ') {\r\n        return [c, 'TK_SEMICOLON'] \r\n      }\r\n\r\n      if (c === '/') {\r\n        let comment = '' \r\n        // peek for comment /* ... */\r\n        if (input.charAt(parser_pos) === '*') {\r\n          parser_pos += 1 \r\n          block_comment_pattern.lastIndex = parser_pos \r\n          let comment_match = block_comment_pattern.exec(input) \r\n          comment = `/*${comment_match[0]}` \r\n          parser_pos += comment_match[0].length \r\n          const directives = get_directives(comment) \r\n          if (directives && directives['ignore'] === 'start') {\r\n            directives_end_ignore_pattern.lastIndex = parser_pos \r\n            comment_match = directives_end_ignore_pattern.exec(input)\r\n            comment += comment_match[0] \r\n            parser_pos += comment_match[0].length \r\n          }\r\n          comment = comment.replace(acorn.lineBreak, '\\n') \r\n          return [comment, 'TK_BLOCK_COMMENT', directives] \r\n        }\r\n        // peek for comment // ...\r\n        if (input.charAt(parser_pos) === '/') {\r\n          parser_pos += 1 \r\n          comment_pattern.lastIndex = parser_pos \r\n          const comment_match = comment_pattern.exec(input) \r\n          comment = `//${comment_match[0]}` \r\n          parser_pos += comment_match[0].length \r\n          return [comment, 'TK_COMMENT'] \r\n        }\r\n\r\n      }\r\n\r\n      if (c === '`' || c === '\\'' || c === '\"' || // string\r\n                (\r\n                  (c === '/') || // regexp\r\n                    (opts.e4x && c === '<' && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{.*?}))*\\s*(\\/?)\\s*>/)) // xml\r\n                ) && ( // regex and xml can only appear in specific locations during parsing\r\n                  (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\r\n                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&\r\n                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||\r\n                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',\r\n                      'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'\r\n                    ]))\r\n                )) {\r\n\r\n        let sep = c,\r\n          esc = false,\r\n          has_char_escapes = false \r\n\r\n        resulting_string = c \r\n\r\n        if (sep === '/') {\r\n          //\r\n          // handle regexp\r\n          //\r\n          let in_char_class = false \r\n          while (parser_pos < input_length &&\r\n                        ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&\r\n                            !acorn.newline.test(input.charAt(parser_pos)))) {\r\n            resulting_string += input.charAt(parser_pos) \r\n            if (!esc) {\r\n              esc = input.charAt(parser_pos) === '\\\\' \r\n              if (input.charAt(parser_pos) === '[') {\r\n                in_char_class = true \r\n              } else if (input.charAt(parser_pos) === ']') {\r\n                in_char_class = false \r\n              }\r\n            } else {\r\n              esc = false \r\n            }\r\n            parser_pos += 1 \r\n          }\r\n        } else if (opts.e4x && sep === '<') {\r\n          //\r\n          // handle e4x xml literals\r\n          //\r\n          const xmlRegExp = /<(\\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{.*?}))*\\s*(\\/?)\\s*>/g \r\n          let xmlStr = input.slice(parser_pos - 1) \r\n          let match = xmlRegExp.exec(xmlStr) \r\n          if (match && match.index === 0) {\r\n            const rootTag = match[2] \r\n            let depth = 0 \r\n            while (match) {\r\n              const isEndTag = !!match[1] \r\n              const tagName = match[2] \r\n              const isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === '![CDATA[') \r\n              if (tagName === rootTag && !isSingletonTag) {\r\n                if (isEndTag) {\r\n                  --depth \r\n                } else {\r\n                  ++depth \r\n                }\r\n              }\r\n              if (depth <= 0) {\r\n                break \r\n              }\r\n              match = xmlRegExp.exec(xmlStr) \r\n            }\r\n            const xmlLength = match ? match.index + match[0].length : xmlStr.length \r\n            xmlStr = xmlStr.slice(0, xmlLength) \r\n            parser_pos += xmlLength - 1 \r\n            xmlStr = xmlStr.replace(acorn.lineBreak, '\\n') \r\n            return [xmlStr, 'TK_STRING'] \r\n          }\r\n        } else {\r\n          //\r\n          // handle string\r\n          //\r\n          // Template strings can travers lines without escape characters.\r\n          // Other strings cannot\r\n          while (parser_pos < input_length &&\r\n                        (esc || (input.charAt(parser_pos) !== sep &&\r\n                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {\r\n            // Handle \\r\\n linebreaks after escapes or in template strings\r\n            if ((esc || sep === '`') && acorn.newline.test(input.charAt(parser_pos))) {\r\n              if (input.charAt(parser_pos) === '\\r' && input.charAt(parser_pos + 1) === '\\n') {\r\n                parser_pos += 1 \r\n              }\r\n              resulting_string += '\\n' \r\n            } else {\r\n              resulting_string += input.charAt(parser_pos) \r\n            }\r\n            if (esc) {\r\n              if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {\r\n                has_char_escapes = true \r\n              }\r\n              esc = false \r\n            } else {\r\n              esc = input.charAt(parser_pos) === '\\\\' \r\n            }\r\n            parser_pos += 1 \r\n          }\r\n\r\n        }\r\n\r\n        if (has_char_escapes && opts.unescape_strings) {\r\n          resulting_string = unescape_string(resulting_string) \r\n        }\r\n\r\n        if (parser_pos < input_length && input.charAt(parser_pos) === sep) {\r\n          resulting_string += sep \r\n          parser_pos += 1 \r\n\r\n          if (sep === '/') {\r\n            // regexps may have modifiers /regexp/MOD , so fetch those, too\r\n            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\r\n            while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {\r\n              resulting_string += input.charAt(parser_pos) \r\n              parser_pos += 1 \r\n            }\r\n          }\r\n        }\r\n        return [resulting_string, 'TK_STRING'] \r\n      }\r\n\r\n      if (c === '#') {\r\n\r\n        if (tokens.length === 0 && input.charAt(parser_pos) === '!') {\r\n          // shebang\r\n          resulting_string = c \r\n          while (parser_pos < input_length && c !== '\\n') {\r\n            c = input.charAt(parser_pos) \r\n            resulting_string += c \r\n            parser_pos += 1 \r\n          }\r\n          return [`${trim(resulting_string)}\\n`, 'TK_UNKNOWN'] \r\n        }\r\n\r\n\r\n\r\n        // Spidermonkey-specific sharp variables for circular references\r\n        // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\r\n        // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\r\n        let sharp = '#' \r\n        if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {\r\n          do {\r\n            c = input.charAt(parser_pos) \r\n            sharp += c \r\n            parser_pos += 1 \r\n          } while (parser_pos < input_length && c !== '#' && c !== '=') \r\n          if (c === '#') {\r\n            //\r\n          } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\r\n            sharp += '[]' \r\n            parser_pos += 2 \r\n          } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\r\n            sharp += '{}' \r\n            parser_pos += 2 \r\n          }\r\n          return [sharp, 'TK_WORD'] \r\n        }\r\n      }\r\n\r\n      if (c === '<' && (input.charAt(parser_pos) === '?' || input.charAt(parser_pos) === '%')) {\r\n        template_pattern.lastIndex = parser_pos - 1 \r\n        const template_match = template_pattern.exec(input) \r\n        if (template_match) {\r\n          c = template_match[0] \r\n          parser_pos += c.length - 1 \r\n          c = c.replace(acorn.lineBreak, '\\n') \r\n          return [c, 'TK_STRING'] \r\n        }\r\n      }\r\n\r\n      if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\r\n        parser_pos += 3 \r\n        c = '<!--' \r\n        while (!acorn.newline.test(input.charAt(parser_pos)) && parser_pos < input_length) {\r\n          c += input.charAt(parser_pos) \r\n          parser_pos++ \r\n        }\r\n        in_html_comment = true \r\n        return [c, 'TK_COMMENT'] \r\n      }\r\n\r\n      if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\r\n        in_html_comment = false \r\n        parser_pos += 2 \r\n        return ['-->', 'TK_COMMENT'] \r\n      }\r\n\r\n      if (c === '.') {\r\n        return [c, 'TK_DOT'] \r\n      }\r\n\r\n      if (in_array(c, punct)) {\r\n        while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\r\n          c += input.charAt(parser_pos) \r\n          parser_pos += 1 \r\n          if (parser_pos >= input_length) {\r\n            break \r\n          }\r\n        }\r\n\r\n        if (c === ',') {\r\n          return [c, 'TK_COMMA'] \r\n        } else if (c === '=') {\r\n          return [c, 'TK_EQUALS'] \r\n        } else {\r\n          return [c, 'TK_OPERATOR'] \r\n        }\r\n      }\r\n\r\n      return [c, 'TK_UNKNOWN'] \r\n    }\r\n\r\n\r\n    function unescape_string(s) {\r\n      let esc = false,\r\n        out = '',\r\n        pos = 0,\r\n        s_hex = '',\r\n        escaped = 0,\r\n        c \r\n\r\n      while (esc || pos < s.length) {\r\n\r\n        c = s.charAt(pos) \r\n        pos++ \r\n\r\n        if (esc) {\r\n          esc = false \r\n          if (c === 'x') {\r\n            // simple hex-escape \\x24\r\n            s_hex = s.substr(pos, 2) \r\n            pos += 2 \r\n          } else if (c === 'u') {\r\n            // unicode-escape, \\u2134\r\n            s_hex = s.substr(pos, 4) \r\n            pos += 4 \r\n          } else {\r\n            // some common escape, e.g \\n\r\n            out += `\\\\${c}` \r\n            continue \r\n          }\r\n          if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {\r\n            // some weird escaping, bail out,\r\n            // leaving whole string intact\r\n            return s \r\n          }\r\n\r\n          escaped = parseInt(s_hex, 16) \r\n\r\n          if (escaped >= 0x00 && escaped < 0x20) {\r\n            // leave 0x00...0x1f escaped\r\n            if (c === 'x') {\r\n              out += `\\\\x${s_hex}` \r\n            } else {\r\n              out += `\\\\u${s_hex}` \r\n            }\r\n            continue \r\n          } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\r\n            // single-quote, apostrophe, backslash - escape these\r\n            out += `\\\\${String.fromCharCode(escaped)}` \r\n          } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {\r\n            // we bail out on \\x7f..\\xff,\r\n            // leaving whole string escaped,\r\n            // as it's probably completely binary\r\n            return s \r\n          } else {\r\n            out += String.fromCharCode(escaped) \r\n          }\r\n        } else if (c === '\\\\') {\r\n          esc = true \r\n        } else {\r\n          out += c \r\n        }\r\n      }\r\n      return out \r\n    }\r\n\r\n  }\r\n\r\n  return {\r\n    run: run\r\n  }\r\n\r\n  /* jshint ignore:end */\r\n  /* jscs:enable */\r\n} \r\n"],"names":["FE","PLUGINS","codeBeautifier","acorn","exports","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","newline","lineBreak","source","allLineBreaks","isIdentifierStart","code","test","String","fromCharCode","isIdentifierChar","run","html_source","options","ltrim","s","replace","rtrim","multi_parser","indent_inner_html","indent_size","indent_character","wrap_line_length","brace_style","unformatted","preserve_newlines","max_preserve_newlines","indent_handlebars","wrap_attributes","wrap_attributes_indent_size","end_with_newline","extra_liners","undefined","parseInt","max_char","indent_char","isNaN","Array","isArray","concat","split","indent_with_tabs","Parser","pos","token","current_mode","tags","parent","parentcount","parent1","tag_type","token_text","last_token","last_text","token_type","newlines","indent_content","Utils","whitespace","single_token","in_array","what","arr","i","length","is_whitespace","text","n","charAt","traverse_whitespace","input_char","input","space_or_wrap","content","line_char_count","print_newline","print_indentation","push","get_content","join","peek3","substr","get_tag","get_contents_to","name","reg_match","lastIndex","reg_array","exec","end_script","index","substring","record_tag","tag","indent_level","retrieve_tag","temp_parent","indent_to_tag","peek","comment","space","first_attr","tag_start","tag_end","tag_start_char","orig_pos","orig_line_char_count","get_unformatted","count","get_comment","tag_complete","tag_index","tag_offset","indexOf","tag_check","toLowerCase","is_unformatted","search","output","start_pos","delimiter","matched","orig_tag","min_index","get_token","type","tag_name_type","get_full_indent","level","indent_string","next_tag","match","printer","js_source","force","print_token","print_token_raw","slice","indent","unindent","t","tag_name","tag_extracted_from_last_output","_beautifier","script_indent_level","js_beautify","css_beautify","indent_scripts","indentation","white","_level","reindent","sweet_code","source_text","NESTED_AT_RULE","CONDITIONAL_GROUP_RULE","indentSize","indentCharacter","selectorSeparatorNewline","selector_separator_newline","newline_between_rules","eol","whiteRe","ch","parenLevel","next","skipWhitespace","result","prev_pos","eatWhitespace","eatString","endChars","start","peekString","endChar","str","eatComment","singleLine","lookBack","foundNestedPseudoClass","openParen","basebaseIndentString","singleIndent","indentLevel","nestedLevel","outdent","print","singleSpace","newLine","_lastCharWhitespace","keepWhitespace","trim","preserveSingleSpace","isAfterSpace","pop","insideRule","insidePropertyValue","enteringConditionalGroup","top_ch","last_top_ch","isAfterNewline","header","variableOrRule","sweetCode","js_source_text","beautifier","Beautifier","beautify","MODE","BlockStatement","Statement","ObjectLiteral","ArrayLiteral","ForInitializer","Conditional","Expression","tokens","token_pos","Tokenizer","current_token","last_type","last_last_text","flags","previous_flags","flag_store","prefix","handlers","opt","baseIndentString","handle_start_expr","handle_end_expr","handle_start_block","handle_end_block","handle_word","handle_semicolon","handle_string","handle_equals","handle_operator","handle_comma","handle_block_comment","handle_comment","handle_dot","handle_unknown","handle_eof","create_flags","flags_base","mode","next_indent_level","indentation_level","just_added_newline","line_indent_level","next_flags","last_word","declaration_statement","declaration_assignment","multiline_frame","if_block","else_block","do_block","do_while","in_case_statement","in_case","case_body","start_line_index","get_line_number","ternary_depth","braces_on_own_line","break_chained_methods","space_in_paren","space_in_empty_paren","jslint_happy","space_after_anon_function","keep_array_indentation","space_before_conditional","unescape_strings","e4x","comma_first","test_output_raw","preindent_index","Output","raw","set_mode","local_token","tokenizer","tokenize","comments_before","handle_token","get_code","keep_whitespace","is_array","split_newlines","idx","out","allow_wrap_or_preserved_newline","force_linewrap","wanted_newline","proposed_line_length","current_line","get_character_count","space_before_token","force_newline","preserve_statement_flags","restore_mode","add_new_line","print_token_line_indentation","whitespace_before","set_indent","printable_token","add_raw_token","previous_line","last","add_token","deindent","is_expression","remove_redundant_indentation","start_of_object_property","start_of_statement","all_lines_start_with","lines","c","line","each_line_matches_indent","len","is_special_word","word","offset","next_mode","line_starters","next_token","second_token","empty_braces","empty_anonymous_function","just_added_blankline","space_before","space_after","directives","j","javadoc","starless","lastIndent","lastIndentLength","OutputLine","_character_count","_indent_count","_items","_empty","baseIndentLength","indent_length","is_empty","item","remove_indent","toString","indent_cache","add_outputline","x","add_space_before_token","frame","output_length","eat_newlines","Token","opts","digit","digit_oct","digit_hex","punct","reserved_words","block_comment_pattern","comment_pattern","directives_block_pattern","directive_pattern","directives_end_ignore_pattern","template_pattern","n_newlines","whitespace_before_token","in_html_comment","parser_pos","input_length","token_values","open","open_stack","comments","tokenize_next","get_directives","directive_match","resulting_string","whitespace_on_this_line","allow_decimal","allow_e","local_digit","charCodeAt","comment_match","sep","esc","has_char_escapes","in_char_class","xmlRegExp","xmlStr","rootTag","depth","isEndTag","tagName","isSingletonTag","xmlLength","unescape_string","sharp","template_match","s_hex","escaped"],"mappings":"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"}